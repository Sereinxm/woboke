[
  
  {
    "title": "项目总结",
    "url": "/posts/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/",
    "categories": "",
    "tags": "",
    "date": "2024-04-01 22:30:00 +0800",
    





    
    "snippet": "介绍：帮助大家找到志同道合的伙伴，移动端 H5 网页功能用户对用户使用标签的分类，标签搜索；实现组队功能，创建和加入队伍，以及邀请他人加入队伍；推荐用户，使用相似度计算算法技术选型Spring Boot优势  内嵌式web容器：Spring boot内置了常见的web容器，你可以直接将你的应用程序打包成Jar文件，无需外部的web服务器。  自动配置：SPringBoot项目依赖自动配置应用...",
    "content": "介绍：帮助大家找到志同道合的伙伴，移动端 H5 网页功能用户对用户使用标签的分类，标签搜索；实现组队功能，创建和加入队伍，以及邀请他人加入队伍；推荐用户，使用相似度计算算法技术选型Spring Boot优势  内嵌式web容器：Spring boot内置了常见的web容器，你可以直接将你的应用程序打包成Jar文件，无需外部的web服务器。  自动配置：SPringBoot项目依赖自动配置应用程序的组件，大大减少了手动配置的工作，提高了开发效率MyBatis-plus优势MyBatis-Plus 是 MyBatis 的增强版框架(就像魂斗罗兄弟一样)，它对 MyBatis 进行了 二次封装，只做增强不做改变。通过提供一系列的 API方法和代码生成器，使重复的 CRUD(创建、读取、更新、删除)操作更加简单，无需手动编写 SOL 语句，从而 大幅提高开发效率。  提供了条件构造器，可以通过编程方式构建复杂的查询条件，无需编写繁琐的SQL 语句  提供了分页查询支持，无需手动编写分页逻辑  提供了一个代码生成器工具，可以根据数据库表自动生成 Java 实体类、Mapper接口和 XML 映射文件，减少了手工编写的工作量。设计库表设计库表时，我考虑了，两种方法一种只建立一张表，在这张表上面新建一列tags，在tag中利用Json去储存；优点：  结构简单，只需要一张表就能实现功能。  对于读取某个用户的所有标签的操作，速度较快，因为只需要一次查询就可以获取到所有信息。缺点：  Json格式的数据在SQL中的查询和索引效率较低。如果你需要频繁地对标签进行查询、过滤或排序等操作，这种方式可能会有性能问题。  要修改或删除某个标签，可能需要读取整个Json字段，然后在应用程序中进行修改，再写回数据库，这在标签数量较多时可能效率较低。  Json字段的可读性较差，不利于数据的管理和维护。另一种是加一个关联表，记录用户和标签的关系优点：  结构规范，符合数据库的第三范式，避免了数据冗余和更新异常。  如果有多个用户都有同一个标签，那么这个标签就会在多个用户的Json字段中重复出现。  如果我们需要修改一个标签（例如，改变它的名字），那么我们就需要在所有包含这个标签的Json字段中进行修改，这就可能导致更新异常。如果在某个地方忘记了修改，就会导致数据不一致。  对于标签的增删改查操作都比较方便，而且可以利用SQL的索引提高查询效率。  可以很方便地统计每个标签被使用的次数，或者查询拥有某个标签的所有用户。缺点：  结构相对复杂，需要额外的关联表来记录用户和标签的关系。  对于查询某个用户的所有标签的操作，可能需要多次查询或者连接查询，效率可能较低。查询效率对比      如果你需要查询某个用户的所有标签，那么第一种方式（单表设计，利用Json存储标签）可能会更快，因为只需要一次查询就可以获取到所有信息。    但是如果你需要执行更复杂的查询，例如查询有某个标签的所有用户，或者统计每个标签被使用的次数等，那么第二种方式（利用关联表记录用户和标签的关系）可能会更快。因为在这种方式下，标签是作为独立的数据项存储的，可以利用SQL的索引提高查询效率。  如果标签数量非常多，第二种方法（使用关联表记录用户和标签的关系）的查询效率通常会更高。开发后端接口密码加密为了保护用户密码的安全，我使用了MD5和盐进行加密  DigestUtils.md5DigestAsHex((SALT + userPassword).getBytes())：这段代码首先将盐和用户密码拼接在一起，然后获取这个字符串的字节表示。然后，使用MD5算法计算这个字节序列的散列值。最后，将这个散列值转换为十六进制字符串。登录时同样使用 String encryptPassword = *DigestUtils*.*md5DigestAsHex*((*SALT* + *userPassword*).*getBytes*());  进行密码校验用户脱敏new一个用户对象，并去除敏感信息如密码，生日等用户头像存储使用阿里云oss存储服务器登录状态记录-session      连接服务器端后，得到一个 session 状态（匿名会话），返回给前端        登录成功后，得到了登录成功的 session，并且给该sessio n设置一些值（比如用户信息），返回给前端一个设置 cookie 的 ”命令“    session =&gt; cookie        前端接收到后端的命令后，设置 cookie，保存到浏览器内        前端再次请求后端的时候（相同的域名），在请求头中带上cookie去请求        后端拿到前端传来的 cookie，找到对应的 session        后端从 session 中可以取出基于该 session 存储的变量（用户的登录信息、登录名）    举个小例子说明Cookie和Session之间的区别和联系假如一个咖啡店有喝五杯赠一杯咖啡的优惠，但是一次性消费5杯咖啡的客人很少，这时就需要某种方式来记录某位顾客的消费数量。无外乎下面的几种方案：1、该店的店员很厉害，能记住每位顾客的消费数量，只要顾客一走进咖啡店，店员就知道该怎么对待了。这种做法就是协议本身支持状态。但是http协议本身是无状态的。2、发给顾客一张卡片，上面记录着消费的数量，一般还有个有效期限。每次消费时，如果顾客出示这张卡片，则此次消费就会与以前或以后的消费相联系起来。这种做法就是在客户端保持状态，也就是cookie，顾客就相当于浏览器。3、发给顾客一张会员卡，除了卡号之外什么信息也不纪录，每次消费时，如果顾客出示该卡片，则店员在店里的记录本上找到这个卡号对应的记录添加一些消费信息。这种做法就是在服务器端保持状态。统一响应结果\"code\": 50001 // 业务状态码\"data\": null\"message\": \"用户操作异常、xxx\"自定义错误码返回类支持返回正常和错误通过自定义一个枚举类来 集中 定义错误码该枚举类提供 code、message、description 三个属性，并且提供一个默认的构造函数用于创建枚举。其中，我对错误码的整型定义是有讲究的，参考真实的 HTTP 状态码将错误进行分类，并且将错误码的前3 位前缀定义为和对应含义的状态码相同，比如 HTTP 状态码 400 表示客户端请求参数错误，那么我在定义一个客户端请求参数的错误码时code 为 40000，示例代码为: PARAMS ERROR(40000，\"请求参数错误”，\"具体描述”)，这样不仅“见码知义”，同时 5 位数的错误码能够预留一定的扩展空间，保证拥有柏同 HTTP 前缀的错误码可以定义 100 个。在抛出异常时，可以传入特定的错误码枚举值作为参数，并且将错误码枚举的message 的 description 属性作为异常类的 message，简化抛出异常的代码。全局异常处理全局异常处理器能够捕获应用程序中抛出的异常，并对这些异常进行统一处理，从而避免因未处理的异常导致系统的崩溃无法正常工作，能够提高系统的稳定性。  错误信息统一处理:全局异常处理器可以将不同种类的异常转化为统一的错误信息格式，提供一致的错误响应给客户端，增强了用户体验。  错误日志记录:可以在全局异常处理器中记录异常信息，包括异常类型、发生时间、请求参数等，有助于排查2 问题和分析系统健康状况  异常信息隐藏: 通过全局异常处理器，可以隐藏敏感信息，以防止敏感信息泄露到客户端。实现使用@RestControllerAdvice注解该类，并用@ExceptionHandler(异常类.class)注解类中的方法；模糊查询搜索标签我是使用的是模糊查询  允许用户传入多个标签，多个标签都存在才搜索出来 and。like ‘%Java%’ and like ‘%C++%’。  允许用户传入多个标签，有任何一个标签存在就能搜索出来 or。like ‘%Java%’ or like ‘%C++%’有内存查询和SQL查询两种方法内存查询这段代码是在Java程序中使用流处理（Stream）和谷歌的Json处理库Gson来实现在内存中搜索用户标签的。具体步骤如下：      首先，使用userMapper.selectList(queryWrapper)从数据库中查询出所有用户的信息，结果存储在userList中。        然后，创建一个Gson对象，用于将Json字符串转换为Java对象。        使用Java 8的流处理功能，对userList进行过滤。过滤条件是：用户的标签集合中包含所有指定的标签。具体实现方式是：        使用stream()方法将userList转换为流。        使用filter()方法对流中的元素进行过滤。过滤条件是一个lambda表达式，该表达式接收一个用户对象，返回一个布尔值。如果返回true，则该用户对象会被保留下来；如果返回false，则该用户对象会被过滤掉。        在lambda表达式中，首先使用Gson将用户的标签Json字符串转换为一个标签集合（Set）。然后，使用Optional.ofNullable()方法防止空指针异常：如果标签集合为null，那么就创建一个新的空集合。        然后，对指定的标签列表进行遍历。如果用户的标签集合中不包含某个指定的标签，那么就返回false，表示该用户不满足过滤条件。        如果用户的标签集合中包含所有指定的标签，那么就返回true，表示该用户满足过滤条件。    最后，使用map()方法将过滤后的用户对象转换为安全的用户对象（可能是去除了敏感信息），然后使用collect()方法将流中的元素收集到一个列表中，作为最终的结果返回。后端整合 Swagger + Knife4j 接口文档Session 共享种 session 的时候注意范围，cookie.domain比如两个域名：aaa.yupi.combbb.yupi.com如果要共享 cookie，可以种一个更高层的公共域名，比如 yupi.comRedis（基于内存的 K / V 数据库）此处选择 Redis，因为用户信息读取 / 是否登录的判断极其频繁 ，Redis 基于内存，读写性能很高，简单的数据单机 qps 5w - 10w自定义线程池插入线程池通俗说明    private ExecutorService executorService = new ThreadPoolExecutor(16, 1000, 10000, TimeUnit.MINUTES, new ArrayBlockingQueue&lt;&gt;(10000));使用StopWatch实现批量导入数据库计时方法时间测试优化利用springAOPAOP英文全称：Aspect Oriented Programming（面向切面编程、面向方面编程），面向切面编程就是面向特定方法编程。AOP面向切面编程和OOP面向对象编程一样，它们都仅仅是一种编程思想，而动态代理技术是这种 思想最主流的实现方式。而Spring的AOP是Spring框架的高级技术，旨在管理bean对象的过程中底层 使用动态代理机制，对特定的方法进行编程(功能增强)。@Component@Aspect //当前类为切面类@Slf4j@Around(\"execution(* com.itheima.service.*.*(..))\")//@Around：环绕通知，此注解标注的通知方法在目标方法前、后都被执行\tpublic Object recordTime(ProceedingJoinPoint pjp) throws\tThrowable {\t\t//记录方法执行开始时间\t\tlong begin = System.currentTimeMillis();\t\t//执行原始方法\t\tObject result = pjp.proceed();\t\t//记录方法执行结束时间\t\tlong end = System.currentTimeMillis();\t\t//计算方法执行耗时\t\tlog.info(pjp.getSignature()+\"执行耗时: {}毫秒\",end-begin);\t\treturn result; \t}}@Around：环绕通知，此注解标注的通知方法在目标方法前、后都被执行@Before：前置通知，此注解标注的通知方法在目标方法前被执行@After ：后置通知，此注解标注的通知方法在目标方法后被执行，无论是否有异常都会执行 @AfterReturning ： 返回后通知，此注解标注的通知方法在目标方法后被执行，有异常不会执行@AfterThrowing ： 异常后通知，此注解标注的通知方法发生异常后执行在Spring AOP（Aspect Oriented Programming）中，@Around, @Before, @After等注解用于定义切面（Aspect），而execution和@annotation则是两种不同的切点（Pointcut）表达式。      execution: 这是最常用的切点表达式，它用于匹配方法执行的连接点。你可以通过这个表达式来指定需要拦截的方法，它的语法如下：    execution(modifiers-pattern? ret-type-pattern declaring-type-pattern?name-pattern(param-pattern)          throws-pattern?)        其中各个部分的含义如下：    modifiers-pattern: 修饰符模式，比如public, protected等。  ret-type-pattern: 返回值类型模式，比如int, void等。  declaring-type-pattern: 声明类型模式，用于匹配方法所在的类。  name-pattern: 方法名模式。  param-pattern: 参数模式，用于匹配方法参数。  throws-pattern: 异常模式，用于匹配方法抛出的异常。例如，下面的表达式会匹配所有返回值为void，且方法名以”set”开头，参数为一个的方法：   @Around(\"execution(void set*(..))\")      @annotation: 这个表达式用于匹配标注了指定注解的方法。例如，下面的表达式会匹配所有标注了@Transactional注解的方法：    @Around(\"@annotation(org.springframework.transaction.annotation.Transactional)\")      总的来说，execution和@annotation都是用于定义切点的表达式，但它们的匹配方式不同。execution更加灵活，可以匹配任何方法，而@annotation则只能匹配标注了指定注解的方法。数据查询慢用缓存：提前把数据取到redis保存好redis数据中文不兼容使用redis自定义序列化器由于 Spring Boot Data Redis 默认使用 JDK 序列化器，会将存储到 Redis 的键值对转化为字节数组，不利于在Redis 可视化工具中阅读、并且不利于跨语言兼容，所以需要指定序列化器。所以我通过新建 RedisTemplateConfig 配置类来创建自定义的 RedisTemplate Bean，并日通过redisTemplate.setKeySerializer(RedisSerializer.string())指定了 Redis Key 的序列化方式。redis使用范围我的项目中，使用 Redis 缓存实现了登录用户信息的存储、主页推荐用户列表的存储。具体的实现方式:  对于登录用户信息的存储，直接使用 spring-session-data-redis 依赖开启对 Redis 分布式 Session 的支持.  对于主页用户推荐列表的存储，我使用 Spring Data Redis 整合 Redis，并通过 RedisTemplate 来操作 Redis根据业务类型设计了缓存 key 的规则，选用 string 数据结构来存储推荐用户列表。redis缓存常见问题            [什么是缓存雪崩、击穿、穿透？      小林coding (xiaolincoding.com)](https://xiaolincoding.com/redis/cluster/cache_problem.html#缓存雪崩)      解决首次数据加载过慢使用spring Scheduler定时任务和cron 表达式进行预加载缓存在分布式场景下，可能有多个服务器实例同时执行同一个定时任务，导致并发问题或重复执行，所以用分布式锁来保证定时任务执行的唯一性。当定时任务要执行时，先去抢锁，只有抢到锁的服务器实例才会执行定时任务。Redisson分布式解决多个用户同时操作或者重复提交带来的数据不一致问题，使用Redisson，提供了开箱即用的分布式锁功能原理：Redis + lua 脚本实现Redisson 分布式锁的实现是基于 Redis 的 SETNX 命令和 Lua 脚本，具体的实现原理如下获取锁:当客户端请求  获取锁时，Redisson 会向 Redis 发送一个 SETNX 命令，尝试将一个特定的键(锁的标1.识)设置为一个特定的值(客户端标识)，并设置锁的超时时间。  争用锁:如果多个客户端同时尝试获取同一个锁，只有一个客户端能够成功设置键的值，其他客户端的 SETNX命令将失败，它们会继续尝试获取锁。  锁超时:为了防止某个客户端获取锁后发生异常导致锁永远不会被释放，Redisson 设置了锁的超时时间。当锁的超时时间到达后，Redisson 会自动释放锁，允许其他客户端获取锁。  释放锁:当客户端执行完锁保护的操作后，可以主动释放锁，这将删除锁的标识键，或者锁的自动超时也会导致锁的释放。  锁的可重入性:Redisson 支持可重入锁，允许同一客户端多次获取同一个锁，然后多次释放锁。只有所有获取锁的次数都释放后，锁才会被完全释放。  锁的续期:如果一个客户端在持有锁时，锁的超时时间即将到期，Redisson会自动为锁续期，防止锁在操作过程中被自动释放。相似度匹配编辑距离算法是一种用于度量两个字符串之间的相似度或差异性的算法，常用于字符串相似度比较、拼写检查等场景。在用户匹配功能中，我使用编辑距离算法来计算用户输入的搜索关键词与已有用户信息的匹配程度，并按照相似度进行排序，从而实现最相似用户的推荐。优先队列TOPN优先队列中的元素按照优先级顺序进行排列，一般优先级越高的元素越早出队。优先队列的插入和删除操作非常高效，并且能够快速访问到优先级最高/低的元素，很适用于査找 Top N 元素、任务调度等场景。在项目中，使用优先队列来存储从数据库中查询出来的 TopN 最相似用户。把相似度作为优先级，淘汰相似度小于当前队列 TopN 的用户，存入相似度大于当前队列 TopN 的用户，将队列的元素个数始终维持在 N 个，从而减少了内存占用。开发组队功能开发涉及多张表格，会出现删除了team却没删除teamuser关联表的情况，这种情况使用数据库事务解决事务注解@Transactional(rollbackFor = Exception.class)要么数据操作都成功，要么都失败部署以宝塔 Linux 原生部署为例:  购买云服务器  安装和初始化宝塔 Linux 面板  在宝塔面板中安装项目部署依赖软件，比如 jdk、mysql、nginx、redis等把本地的数据同步到宝塔安装的线上数据库  后端:把本地 mvn package 命令打好的 jar 包上传到 Linux 服务器，配置启动参数和激活配置(prod)，点击“启动”即可。  前端:上传本地打包好的 dist 网站静态文件目录到服务器，然后配置 Nginx 指向文件目录路径，即可访问前端静态文件  在 Nginx 配置反向代理，请求服务器 IP(或域名时)+后端路径(/api)时，请求转发到服务器内的实际后端服务端口(比如localhost:8080)  在服务器运营商提供的界面和宝塔面板界面中开启防火墙的 80 端口跨域      配置 @CrossOrigin 注解        添加 web 全局请求拦截器  @Configurationpublic class WebMvcConfg implements WebMvcConfigurer {     @Override    public void addCorsMappings(CorsRegistry registry) {        //设置允许跨域的路径        registry.addMapping(\"/**\")                //设置允许跨域请求的域名                //当**Credentials为true时，**Origin不能为星号，需为具体的ip地址【如果接口不带cookie,ip无需设成具体ip】                .allowedOrigins(\"http://localhost:9527\", \"http://127.0.0.1:9527\", \"http://127.0.0.1:8082\", \"http://127.0.0.1:8083\")                //是否允许证书 不再默认开启                .allowCredentials(true)                //设置允许的方法                .allowedMethods(\"*\")                //跨域允许时间                .maxAge(3600);    }}Docker部署docker 是容器，可以将项目的环境（比如 java、nginx）和项目的代码一起打包成镜像，所有同学都能下载镜像，更容易分发和移植。Dockerfile 用于指定构建 Docker 镜像的方法  不用输命令来操作，更方便省事  不用在控制台操作，更傻瓜式、更简单  大厂运维，比自己运维更省心  额外的能力，比如监控、告警、其他（存储、负载均衡、自动扩缩容、流水线）"
  },
  
  {
    "title": "设计大赛",
    "url": "/posts/%E8%AE%BE%E8%AE%A1%E5%A4%A7%E8%B5%9B/",
    "categories": "",
    "tags": "",
    "date": "2024-02-17 22:59:00 +0800",
    





    
    "snippet": "视频介绍链接：点击访问  需求分析1.1.开发目的我们在日常生活中经常会填写一些表单，但现有的常用工具如金山表单、腾讯文档等有一些缺点，功能并不完善。例如：我们发现目前表单收集都在群聊发送，然而面对具有组织架构的企业或学校在收集信息时，需要上级逐层下发信息到下级，下级还需要收集信息逐层汇总到上级，期间无法实时监控数据收集进度，面对这些问题开发了我们的项目1.2.主要功能我们在实现现有收集工具...",
    "content": "视频介绍链接：点击访问  需求分析1.1.开发目的我们在日常生活中经常会填写一些表单，但现有的常用工具如金山表单、腾讯文档等有一些缺点，功能并不完善。例如：我们发现目前表单收集都在群聊发送，然而面对具有组织架构的企业或学校在收集信息时，需要上级逐层下发信息到下级，下级还需要收集信息逐层汇总到上级，期间无法实时监控数据收集进度，面对这些问题开发了我们的项目1.2.主要功能我们在实现现有收集工具的功能的基础上添加了新的功能，添加了组织架构系统，通过发布任务收集信息，实现从表单制作到任务发布到数据收集，数据可视化与统计，最后导出数据一条龙服务，让使用者更加方便。我们产品主要是利用表单收集信息，但利用表单与组织架构进行创新融合，弥补原有表单收集工具不足。  让制作表单更自由：表单制作有丰富的控件，其中还包含富文本等高级控件，支持js，css的高级编辑功能，可以完全实现表单的自定义化，并且可以将表单保存为PDF实现打印。2.让收集信息更方便：我们具有集团式的组织架构，在建立组织，分级管理的同时可以实现表单一键精准投放多个部门，并可以提前预约时间发送及设置截止时间，省时省力。此外，还可以在收集过程中实现实时监控，可随时查看进度及完成情况，能及时对未完成人员发送邮件提醒。3.让数据处理更省心：收集数据可以导出Excel也可以打包文件，同时有可视化饼状图、条形图使数据详情更加清晰明了，不同管理员查看数据范围不同，保护数据隐私。1.3.对标用户我们的系统适用对人员和组织监控管理功能有需求的组织，小到数人团体，大到学校、企业、政府。1.4.竞品分析现阶段金山表单、腾讯文档是最常见的表单任务收集工具，相较于我们的产品，其缺少对组织精准管理，并且无法动态的查看表单完成情况，不透明，效率较低等。            名称 功能      金山表单      腾讯文档      OFTS                  自定义设置表单      √      √      √              导出Excel      √      √      √              链接分享      √      √      √              任务的定时控制      √      ×      √              提醒完成      √      ×      √              统计图展示      不完整      ×      √              多种字段样式      ×      ×      √              实时监控数据      ×      ×      √              数据可视化      ×      ×      √              加入对应组织      ×      ×      √              分级限权      ×      ×      √      表一：常用工具功能比对第二章 概要设计2.1.项目架构图一：项目架构图二：框架关系2.2.功能模块图三：OFTS功能模块第三章 详细设计3.1.设计思路我们将组织架构与表单进行融合创新，将市面上用于前端设计的表单构建工具改造为表单设计器，改造任务也是这次软件的重点和难点，毕竟用于前端制作的表单工具与现实使用的表单制作还是有些区别的。在组织架构方面有人员和组织两类，为了简化权限分配操作，摒弃了 RBAC 模型，采用以树型结构类型的自动权限分配，即本节点管理员只有权管理和查看本节点及其子节点的数据，因此不同节点上的管理员在人员，组织和表单数据上的数据权限是不同的，简化了繁琐的权限分配工作，也保证了数据的安全和完整性。在数据收集方面有表单，任务，数据三类，表单设计器制作的模板将会保存在表单列表中可随时复用和修改，任务就是通过发布表单来收集数据的，任务通过选中的组织向下传递给对应的组织成员，简化了传统表单的分享操作，也使得任务的数据与组织相关联，即可实时查看各组织进度进行提醒，也可根据不同组织得到不同的数据分析报告。3.2.设计难点  本项目采用前后端分离技术，需要使用跨域，校验等技术，前端使用vue框架,echart图表,excel导出，pdf导出，element ui还有其它开源组件，学习成本高。  在前端表单设计器转换为表单设计器时，需要考虑到用户并不会前端知识，需要将原有的前端表单设计工具更改为大众都可接受的简易设计方式，例如本该使用js代码完善的文件上传，下载等功能，然而这全部需要自动去生成js代码来简化表单的设计难度。  在获取表单数据并转换为 excel 时，返回的数据并不能直接使用，这需要深度解析表单结构，在表单中寻找，每个表单的控件返回的数据类型不同，有数组，对象，字符串，数字等不同数据类型，这需要在获取表单时对表单每个控件都要进行类型判断，将不同类型数据转换为统一的字符串类型，这样才可将数据放入excel中。然而表单是容器与字段嵌套而成的树形结构，遍历起来也很繁琐。  在权限分配上，表单，人员，组织，任务，填写数据等等都需要根据权限的不同返回不同的数据，在后端处理上全部都需要进行权限校验。3.3.数据库设计图一:E-R 图说明补充：数据与组织的外键是为了避免跨表查询操作，提高查询速度，同时有利于通过组织对数据进行反向查询。3.4.接口设计用户校验：使用JWT token验证后端接口：使用REST接口规范请求规范（以books书籍案例）            请求方式      响应      含义                  GET /books      返回资源对象的列表（数组）[{},{},{}]      获取所有书籍              GET /books/1      返回单个资源对象      获取一本书籍              POST /books      返回新生成的资源对象      添加一本书籍              PUT /books/1：      返回修改后完整的资源对象      修改一本书籍部分内容              PATCH /books/1      返回修改后完整的资源对象      修改一本书籍全部内容              DELETE /books/1：      返回空      删除一本书籍      表一：请求规范相应规范            正常响应      重定向响应      客户端异常      服务器异常                  响应状态码2xx      响应状态码3xx      响应状态码4xx      响应状态码5xx              200：常规请求      301：永久重定向      403：请求无权限      500：服务器异常              201：创建成功      302：暂时重定向      404：请求路径不存在                                   405：请求方法不存在             表二:规范表格图一：页面地址REST接口            网址      操作对象                  user      用户              Groups      组织              Forms      表单              datas      数据              Tasks      任务              Mytask      我的任务              Userinfo      用户信息              Files      文件      表三：REST接口其它API接口            login/      post      用户登录                  grouptree/      get      返回嵌套类型的组织树结构              data/int:pk/      get      返回任务收集的数据      表四：API接口3.5.界面设计3.5.1.登录页面设计图一：登录页介绍3.5.2.首页图二首页介绍3.5.3. 用户管理(1) 组织树图三：组织树管理界面3.5.4.表单管理(1) 表单设计图四：表单设计界面(2)表单列表图五：表单管理页面3.5.5.任务管理(1) 任务列表图六：任务管理页面(2) 任务进度图七：任务进度管理页面(3) 数据可视化图八：可视化图表第四章 测试报告Api接口测试网站后端拥有 api 接口测试平台，直接访问网站根目录(124.222.152.140,后端为90端口)即可在线调试查看。4.1.网站测试4.1.1.网站性能测试按导航栏从上到下依次打开界面，箭头划分不同界面网络，FPS，动画，内存测试结果图一：网站性能（1）图二：网站性能（2）4.1.2.Lighthouse测试            表单列表界面                        表单设计界面                    任务列表界面                    首页界面                    我的任务界面                    我的信息界面                    用户列表界面                    组织列表界面                    组织树界面            4.2．功能测试4.2.1.添加用户的两种方式图一：用户添加方式4.2.2.PDF导出功能图二：导出PDF4.2.3.对未完成人员发邮件提醒图三：查看数据进度图四：发送邮件图五：邮件内容4.4.导出Excel4.4.1.导出方法图六：表格导出方法4.4.2.exsel导出实例展示图七：导出表格展示第五章 安装及使用5.1.在线演示网址本项目已部署，可以直接访问项目网址查看，可以无需安装网址：http://124.222.152.140:89/后端接口：http://124.222.152.140:90/账号：cao12345密码：cao12345使用流程可参考演示视频若要安装在本地环境请参考下面教程（前端使用vue，后端使用django）5.2.前端安装详细可参考网上教程：vue安装5.2.1. 下载 node.js32 位 windowhttps://npmmirror.com/mirrors/node/v16.14.2/node-v16.14.2-x86.msi64 位 windowhttps://cdn.npmmirror.com/binaries/node/v16.14.2/node-v16.14.2-x64.msi5.2.2.设置镜像地址由于网络原因，npm 在国内使用比较慢，建议切换 npm 源到国内镜像。以管理员身份运行 “命令提示窗口”，输入npm config set registry= https://registry.npm.taobao.org如图所示：图一：输入命令展示5.2.3. 安装依赖通过 cd 命令进入 my_admin 所在文件夹下成功后输入npm i –legacy-peer-deps它告诉 npm 忽略项目中引入的各个 modules 之间的相同 modules 但不同版本的问题并继续安装，保证各个引入的依赖之间对自身所使用的不同版本 modules 共存。5.2.4.输入运行命令文件目录下会出现以 node_modules 命名的文件夹 在命令提示窗口中输入npm run serve5.2.5.进入项目界面当出现 http://localhost:8080/ 时，说明项目已经正常运行，将链接复制后在浏览器中打开图二：运行界面图三：运行结果5.3.后端安装详细教程可参考网上教程：https://www.runoob.com/note/537325.3.1.Python安装安装python5.3.2.安装依赖终端中执行pip install -r requirements.txt5.3.3.配置项目进入 settings.py 文件图四：文件位置展示5.3.4.配置数据库选项图五：数据库配置项可在数据库直接执行 sql 文件生成数据表及其数据如果没有 sql 文件，数据库中没有数据表可在终端中依次运行命令来生成数据表python3 manage.py makemigrationspython3 manage.py migrate5.3.5.运行项目python3 manage.py runserver然后访问 http://127.0.0.1:8000/ 网址即可第六章 项目总结6.1.项目协调6.2.开发感悟通过这次比赛，每一位团队成都员意识到实践的重要性，又学会了发现问题解决问题，每解决一个问题对自己来说都是一次进步。同时也学到了django，vue，前后端分离技术等，懂得了一点点网站的开发流程，从0开始到网站部署，一路艰辛但硕果累累，通过本次参赛，每一位团队成员都得到了很多收获，虽然过程艰辛但是硕果累累，并且不断激励自己成长。6.3.社会价值眼当下，在信息数字化的大背景之下我们的产品可以有效为社会企业等提供了一个信息处理、共享、数据可视化、高效的平台，为城市信息化数据管理尽绵薄之力，为人民提供更优质的服务。6.4.发展前景如今任务管理模式才是未来协同办公的大势所趋，从国内主要”远程协同办公”软件的融资情况和发展情况可以看出，协同办公软件主要焦距四大应用场景：IM通讯、在线文档、视频会议和任务管理。其中，IM通讯、视频会议和在线文档已经发展了多年，具备非常成熟的技术和解决方案，因此，未来难以出现突破性创新。而任务管理则不同。我们适应于即时通讯，云存储，客户管理，合同管理，等多种业务场景需求。这每个场景背后都有相应的协作功能和信息化系统作为支撑、OFTS系统，在当下乃至未来都会有巨大的市场。6.5.后续升级我们考虑后期能把系统功能嫁接到微信端，连接微信小程序，让使用者更加方便快捷。此外，以后我们的产品不仅仅是用表单来将数据收集为excel，还可也反向而行，利用excel将数据推送到个人表单达到数据的推送。表单其实也不只是用来收集，也可制作为打卡，试卷评测，作业提交等多种格式，值得我们去挖掘它的潜力。"
  },
  
  {
    "title": "数学建模",
    "url": "/posts/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/",
    "categories": "",
    "tags": "",
    "date": "2024-01-17 22:59:00 +0800",
    





    
    "snippet": "  如果图片无法加载，请见腾讯文档：点我",
    "content": "  如果图片无法加载，请见腾讯文档：点我"
  },
  
  {
    "title": "基于哈夫曼树压缩—数据结构设计",
    "url": "/posts/%E5%9F%BA%E4%BA%8E%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%E5%8E%8B%E7%BC%A9-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1/",
    "categories": "",
    "tags": "",
    "date": "2023-06-25 15:11:00 +0800",
    





    
    "snippet": "基于哈夫曼树压缩1 设计目标从文件中读取一篇英文短文（有标题和至少两段文字，单词个数不少于500），根据短文中每个字符出现频率（字符区分大小写），构造哈夫曼树并对短文进行压缩（哈夫曼编码），先输出每个字符的哈夫曼编码，及编码后的短文（以文件形式存储），再对编码后的短文进行译码（存储到另外一个文件中）。 注意：对短文进行编码，只需用每个字符的哈夫曼编码（01代码串）替换原字符即可；译码时，将0...",
    "content": "基于哈夫曼树压缩1 设计目标从文件中读取一篇英文短文（有标题和至少两段文字，单词个数不少于500），根据短文中每个字符出现频率（字符区分大小写），构造哈夫曼树并对短文进行压缩（哈夫曼编码），先输出每个字符的哈夫曼编码，及编码后的短文（以文件形式存储），再对编码后的短文进行译码（存储到另外一个文件中）。 注意：对短文进行编码，只需用每个字符的哈夫曼编码（01代码串）替换原字符即可；译码时，将01代码串翻译为原来的字符。2 课题分析与设计2.1 课题分析（1）统计要压缩的文件中各字符出现的次数，利用数据结构中的小堆来构建Huffman树，每次在堆顶选出两个出现次数较小的字符先进行构建，将它们相加的结果又放进堆里面，直到堆里面的数据被取完，这样字符出现次数多的离Huffman树的根节点就比较近，字符出现次数少的离Huffman树的根节点就比较远。（2）根据构建好的Huffman树写出Huffman code，规定向左为“0”向右为“1”，这样字符出现次数多的Huffman code较短，字符出现次数少的Huffman code较长。（3）根据Huffman code 对原文件进行压缩，因为Huffman code刚好为“0”、“1”序列，所以可以每8位为一个字节写进压缩文件中，当余下的位数不够8位写不成一个字节时，需要在后面补0够一个字节再写入，这样就完成了文件的压缩，但要注意后面补0的位数为文件解压缩留下了隐患。（4）在上个步骤压缩时由于后面不够一个字节在后面补了0，但是在解压缩的时候我们并不知道在进行压缩的时候在后面到底补了多少位0，而且在进行解压缩的时候我们还是需要用到Huffman树的结构，这时候我就想到用一个配置文件来记录原文件字符出现的总次数和每个字符分别出现的次数，这样在解压缩的时候直接去配置文件中读取需要的信息即可。（5）读取配置文件中存放的信息，再次构建Huffman树，读取压缩文件，从huffman树的根节点开始找，每次遇到叶子结点就停止，将叶子结点所对应的字符写进解压缩文件，注意这里不能将压缩文件全部读完，只需要还原配置文件中所记录的总的字符个数个即可，这就完成了文件的解压缩。题目中要求构建哈夫曼数，则需要统计字母的权数（即出现次数），又因为在“输出字母和对应出现次数”以及“输出字母和对应的编码”的两个操作中，都要求“以ASCII码从小到大顺序”输出，所以想到用一个专门的变量来存放字母和出现次数的信息，并且对这些信息以ASCII码从小到大进行排序操作。对于译码操作，首先要明确译码的对象，即对输入字符串的编码进行译码操作。那么对于如何获得译码操作对象。1.从txt文件中取出文本定义一个足够大的二维字符串数组，用以存放每组字符串，直到输入的字符串为”0”时结束。若当前字符串不为”0”（即当前字符串首元素不为’0’），在循环中完成，在提取文本时，要使用get来使其能读取整篇文章，而不是对每一个单词进行处理。2.创建一个字母表并对字母进行排序构造一个空的顺序表，为其分配一个大小为60的数组空间（小写字母有54个，另外在多申请空间防止出现bug），空表长为0，数据元素由字母及出现次数count两个数据项组成。在put函数中，依次遍历字符串中的字母，每遍历一个字母，都在表CH中进行一次查找，若未找到则为新字母，存入表CH中，count置为1，若找到则不是新字母，使该字母次数count加1。在Put函数中具体完成以下操作：1)整型变量i为字符串数组下标，赋初值为0。2)当前字符不为’\\0’时，在循环中完成以下操作：[1] 定义整型变量j并赋初值为1，j用以表示当前表CH的数组元素下标；定义p指向表CH存放的第一个元素。[2] 在表CH中查找当前字母。当j小于等于当前表长时，在循环中完成以下操作：Ø 若p当前指向字母为要找的字母，则字母次数加1，结束循环；否则p指向表中下一个元素，j加1；Ø 若j大于表长，则说明未找到该字母，将新字母存入表中，次数设为1，表长加1。[3] 判断下一个字符，即i加1。3)在Arrange函数中按字母ASCII码从小到大对表CH元素排序，采用选择法。3.构造哈夫曼树函数\\1) 初始化：动态申请2n（n为不同字母的个数，即CH表长）个单元；然后循环2n-1次，从一号单元开始，依次将1至2n-1所有单元中双亲、左孩子、右孩子的下标都初始化为0；最后再循环n次，输入前n个单元中叶子节点的权值，即各字母的次数。可见权值所在单元下标与对应CH中字母所在单元下标相同。\\2) 创建树：循环n-1次，通过n-1次的选择、删除与合并来创建哈夫曼树。i为当前未存放数据的单元下标，取值范围为n+1——2n-1，每完成一次循环i加1，当i小于等于2n-1时，在循环中完成下列操作：[1]选择：定义整型变量s1，s2；调用Select函数，将当前森林中双亲为0且权值最小的两个树根结点下标赋给s1，s2；[2]删除：s1，s2单元的双亲域赋值为当前结点下标i；[3]合并：当前结点的左孩子为s1,右孩子为s2，权值为s1与s2权值之和。4.选择最小权值函数需满足最小权值元素无双亲，以及s1，s2不同。\\1) 确定s1:通过循环找到当前森林中首个无双亲的元素下标并赋值给s1;从s1+1开始，寻找无双亲且权值比s1小的下标，赋给s1。\\2) 为保证s2与s1不同，先将s1的双亲置为1。\\3) 确定s2：通过循环找到当前森林中首个无双亲的元素下标并赋值给s2；从s2+1开始，寻找无双亲且权值比s1小的下标，赋给s2。\\4) 将s1的双亲重新置为0。5.编码函数定义typedef char **HuffmanCode，各字符的哈夫曼编码存储在由HuffmanCode定义的动态分配的数组HC中，从1号单元开始使用，数组长度为n+1。因为每个字符编码的长度事先不能确定，所以不能预先为每个字符分配大小合适的存储空间。为不浪费存储空间，动态分配一个长度为n的（由哈夫曼编码的特点可知，字符编码长度一定小于n）的一维数组cd，用来临时存放当前正在求解的第i（1≤i≤n）个字符的编码，当第n个字符的编码求解完后，根据数组cd字符串长度分配HC[i]的空间，然后将数组cd的编码复制到HC[i]中。因为求解编码时是从哈夫曼树的叶子出发，向上回溯至根结点。所以对每个字符，得到的编码顺序是从右向左的，故将编码向数组cd存放的顺序也是从后向前的，即每个字符的第1个编码存放在cd[n-2]中（cd[n-1]存放字符串结束标志’\\0’），第2个编码存放在cd[n-3]中，依此类推，直到全部编码存放完毕。6.输出编码函数逐个遍历每个字母，在表CH中找到该字母的下标，此下标也是该字母的编码在编码表HC中的下标，输出对应编码，并将该编码连接在字符串encode中，为译码做准备。7.译码函数由哈夫曼树的特点可知，对于由n个叶子节点的哈夫曼树，每个叶子节点到根节点的路径数最多为n-1，即编码位数最多为n-1；此外，哈夫曼编码为前缀编码。从以上两个特点想到如下思路：定义一个变量i用来表示当前截取长度。从路径数i=1开始，在编码字符串encode中截取长度为i的编码并存放在node字符串数组中；在HC中查找截取的编码，若找到，则记录下标，通过下标输出表CH中的字母，移动指针p以重新定位下次截取的起点，移动长度为当前截取长度i；若未找到，则将路径数加一再次截取编码进行查找，直到找到。重复上述操作直到所有编码都译完（即p指向数组首元素不为’\\0’）。具体操作如下:-&gt;使p指向数组encode；当p当前指向的首元素不为’\\0’时，在循环中完成以下操作1)定义字符串数组code[n]，用以存放截取的编码；初始化i=1，表示截取的编码长度。2)将p指向数组的前i个字母赋给code（调用strncpy函数），然后将下标为i的数组元素赋字符串结束标志’\\0’。3)调用find_code函数，在HC中找code字符串。若查找成功，将下标赋给变量subscript，返回OK；若查找失败，则返回0。函数的返回值和i取值范围作为循环的条件，当查找失败时，在循环中进行以下操作：[1]截取长度i加1；[2]按新的截取长度将p指向数组的前i个字母赋给code（调用strncpy函数），然后将下表为i设为数组元素赋字符串结束标志’\\0’。4)循环结束，即查找成功，按下标subscript在表CH输出对应字母。5)p越过截取长度i，指向新的数组首部，即p=p+i。2.2 存储结构设计构造一个空的顺序表，为其分配一个大小为60的数组空间（小写字母有54个，另外在多申请空间防止出现bug），空表长为0，数据元素由字母及出现次数count两个数据项组成。设计哈夫曼树进行存储weight：结点的权值;Parent：双亲结点在数组中的下标Lchild：左孩子结点在数组中的下标Rchild：右孩子结点在数组中的下标n个叶子的哈夫曼，恰有n-1个度为2的结点，即哈夫曼树共有2n-1个结点数组存储这棵哈夫曼树的所有结点及逻辑关系，其中前256个元素存储Huffman树的叶子结点，其余存储的是非叶子结点。说明：一个字节可采用unsigned char表示，同时也可表示该字节位于数组的下标，如十六进制为0x00，转化成int即为0，故数组下标为0表示字节00的信息。由于叶子结点为256个，非叶子结点为255，所以编码长度不可能超过256void CreateHuffmanTree(HuffmanTree &amp;HT, int n, LTList CH){if(n&lt;=1) return;int m=2*n-1;int i;HT = new HTNode[m+1];for(i=1; i&lt;=m; i++){    HT[i].parent=0;   HT[i].lchild=0;    HT[i].rchild=0;}for(i=1; i&lt;=n; i++)​    HT[i].weight = CH.letter[i].count;​for(i=n+1; i&lt;=m; i++){​    int s1, s2;​    Select(HT, i-1, s1, s2);​    HT[s1].parent=i; HT[s2].parent=i;​    HT[i].lchild=s1; HT[i].rchild=s2;​    HT[i].weight = HT[s1].weight+HT[s2].weight;}}2.3 算法设计（1）首先遍历要处理的字符串，得到每个字符的出现的次数；（2）将每个字符（以其出现次数为权值）分别构造为二叉树（注意此时的二叉树只有一个节点）；（3）取所有二叉树种种字符出现次数最小的二叉树合并为一颗新的二叉树，新二叉树根节点的权值等于两个子节点的权值之和，新节点中的字符忽略；（4）重复过程③直到所有树被合并为同一棵二叉树（5）遍历最后得到的二叉树，自顶向下按路径编号，指向左节点的边编号0，指向右节点的边编号1，从根到叶节点的所有边上的0和1链接起来，就是叶子节点中字符的哈夫曼编码。3测试3.1 测试数据Eleanor Roosevelt was the First Lady of the United States from 1933 to 1945. She supported the New Deal policies of her husband, Franklin Delano Roosevelt, and became an advocate for civil rights. After her husbands death in 1945, Roosevelt continued to be an international author, speaker, politician, and activist for the New Deal coalition.Even at 14, Roosevelt understood that ones prospects in life were not totally dependent on physical beauty, writing wistfully that no matter how plain a woman may be if truth and loyalty are stamped upon her face all will be attracted to her.Roosevelt was tutored privately and, at the age of 15, with the encouragement of her fathers sister, her aunt Bamie, the family decided to send her to Allenswood Academy, a private finishing school outside London, England. The headmistress, Marie Souvestre, was a noted feminist educator who sought to cultivate independent thinking in the young women in her charge. Eleanor learned to speak French fluently and gained self-confidence. Her first-cousin Corinne Robinson, whose first term at Allenswood overlapped with Eleanors last, said that when she arrived at the school, Eleanor was everything. She would later study at The New School in the 1920s.In 1902 at age 17, Roosevelt returned to the United States, ending her formal education. On December 14, 1902, Roosevelt was presented at a debutante ball at the Waldorf-Astoria hotel. She was later given a debutante party. As a member of The New York Junior League, she volunteered as a social worker in the East Side slums of New York. Roosevelt was among the Leagues earliest members, having been introduced to the organization by her friend, and organization founder, Mary Harriman.03.2 测试结果及分析结果中输出了每一个字符出现的频率，及其每个字符的哈夫曼编码和译码，并将其保存在out.txt文件中4 总结4.1 收获通过做哈夫曼树进行数据压缩实验，更加深刻并灵活的掌握了哈弗曼树的构造和哈夫曼编码，可以更加熟练地运用顺序表。明白了一些写代码的思路，其实每个程序都有一些共同点，有通用的结构。此次课程设计的成功，是我和我的同学两个人共同努力的结果，进行完这个课程设计后，我们的编程设计有了明显的提高，同时也增强了我们团结协作的能力。4.2 不足书本上的知识与老师的讲解都比较容易理解，但是当自己采用刚学的知识点编写程序时却感到十分棘手，有时表现在想不到适合题意的算法,有时表现在算法想出来后，只能将书本上原有的程序段誊写到自己的程序中再加以必要的连接以完成程序的编写。并且有些C语言基础知识掌握的不牢固，许多具体的代码写不出来，需要在网上查找资料来完成。4.3 算法改进分析我们的算法有许多不足的地方，刚开始只能识别小写字母，后来经过仔细检查和查找相关资料，找到了问题所在，修改了程序，现在可以识别大小写。但是程序运行效率不高，需要继续精进程序，提高程序运行效率。#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;iostream&gt;#include&lt;string.h&gt;#define MAXSIZE 999#define OK 1#define OVERFLOW -2using namespace std;typedef int Status;typedef struct{\tchar c;\tint count;}LTNode;  //字母表的数据元素由字符和出现次数两个数据项组成typedef struct{\tLTNode *letter;\tint length;  //字母表长度 }LTList;  typedef struct{\tint weight;  //结点的权值\tint parent, lchild, rchild;  //结点的双亲、左孩子、右孩子的下标}HTNode, *HuffmanTree;typedef char **HuffmanCode;  //动态分配数组存储哈夫曼编码表Status InitLTList(LTList &amp;CH);  //初始化字母信息表 void Put(LTList &amp;CH, char str[]);void Arrange(LTList &amp;CH);  //排序 void CreateHuffmanTree(HuffmanTree &amp;HT, int n, LTList CH);  //构造哈夫曼树 void Select(HuffmanTree HT, int len, int &amp;s1, int &amp;s2);  //选择两个无双亲条件下权数最小的下标 void printHuffmanTree(HuffmanTree HT, int n);  //输出哈夫曼树 void CreateHuffmanCode(HuffmanTree HT, HuffmanCode &amp;HC, int n);  // 构造编码表 void printEncode(HuffmanCode HC, char str[], LTList CH, char encode[]);  //编码函数 void printDecode(HuffmanCode HC, char encode[], LTList CH);  //译码函数 Status find_code(char node[], HuffmanCode HC, int &amp;subscript, int len);  //在HC中寻找该编码是否存在 int main(){\tfreopen(\"in.txt\", \"r\",stdin);\tfreopen(\"out.txt\", \"w\", stdout);\tchar ch[MAXSIZE][MAXSIZE];  //定义一个足够大的二维数组，用来存放输入的每组字符串 \tint t=0;\tgets(ch[t]);\twhile(ch[t][0]!='0')  //输入字符串，直到输入字符串为0时结束 \t{\t\tt++;\t\tgets(ch[t]);\t}\t\tt=0;\twhile(ch[t][0]!='0')  //当某组字符串不为零时，执行以下操作 \t{\t\tchar str[MAXSIZE];  //定义一个数组，用来存放当前进行操作的字符串 \t\tstrcpy(str, ch[t]);\t\tt++;  //t加1，为下次循环做准备 \t\t\tLTList CH;  //初始化字母信息表，用以存放字母以及出现的次数,从下标为1开始存放\t\tInitLTList(CH);  //初始化字母信息表 \t\tPut(CH, str);  //构造字母信息表 \t\t\tArrange(CH);  //按字母顺序从小到大重新排序\t\tint i;\t\ti=1;\t\twhile(i&lt;=CH.length)   //输出字母及次数 \t\t{\t\t\tif(i!=1) printf(\" \");  //每两个信息间有一个空格 \t\t\tprintf(\"%c:%d\", CH.letter[i].c, CH.letter[i].count);\t\t\ti++;\t\t}\t\tprintf(\"\\n\");\t\tHuffmanTree HT;   \t\tint len=CH.length;  //哈夫曼树HT的叶子节点长度即为字母信息表长度 \t\tCreateHuffmanTree(HT, len, CH);  //构造哈夫曼树\t\tprintHuffmanTree(HT, 2*len-1);  //输出哈夫曼树终态 \t\t\tHuffmanCode HC;\t\tCreateHuffmanCode(HT, HC, CH.length);  //构造编码表 \t\t\ti=1;\t\twhile(i&lt;=len)  //输出字母及对应编码 \t\t{\t\t\tif(i!=1) printf(\" \");  //每两组信息间有一个空格 \t\t\tprintf(\"%c:%s\", CH.letter[i].c, HC[i]);\t\t\ti++;\t\t}\t\tprintf(\"\\n\");\t\t\tchar encode[MAXSIZE]=\"\\0\";\t\tprintEncode(HC, str, CH, encode);\t\tprintf(\"\\n\");\t\tprintDecode(HC, encode, CH);\t\tprintf(\"\\n\");\t}} Status InitLTList(LTList &amp;CH) {\tCH.letter = new LTNode[54];\tif(!CH.letter) exit(OVERFLOW);\tCH.length=0;\treturn OK; }void Put(LTList &amp;CH, char str[]){\tint i=0;\twhile(str[i]!='\\0') \t{\t\tint j=1;\t\tLTNode *p=CH.letter;\t\tp++;\t\twhile(j&lt;=CH.length)\t\t{\t\t\tif(p-&gt;c==str[i])\t\t\t{\t\t\t\tp-&gt;count++;\t\t\t\tbreak;\t\t\t}\t\t\telse\t\t\t{\t\t\t\tp++;\t\t\t\tj++;\t\t\t}\t\t}\t\t\tif(j&gt;CH.length)  //未找到相同字母，是一个新的字母 \t\t\t{\t\t\t\tp-&gt;c=str[i];  //将新字母放入新的单元\t\t\t\tp-&gt;count=1;  //新字母出现的次数设为1\t\t\t\tCH.length=CH.length+1;  //表长加1 \t\t\t}\t\t\ti++;\t}}void Arrange(LTList &amp;CH)  //选择法排序{\tint i, j, k;  //i用于外循环，j用于内循环，k用于记录每层内循环中最小元素的下标\tfor(i=1; i&lt;CH.length; i++)\t{\t\tk=i;\t\tfor(j=i+1; j&lt;=CH.length; j++)\t\t\tif(CH.letter[k].c&gt;CH.letter[j].c) k=j;\t\tif(k!=i)\t\t{\t\t\tLTNode temp;\t\t\ttemp=CH.letter[i];\t\t\tCH.letter[i]=CH.letter[k];\t\t\tCH.letter[k]=temp;\t\t}\t}}void CreateHuffmanTree(HuffmanTree &amp;HT, int n, LTList CH){\tif(n&lt;=1) return;\tint m=2*n-1;\tint i;\tHT = new HTNode[m+1];\tfor(i=1; i&lt;=m; i++)\t{\t\tHT[i].parent=0;\t\tHT[i].lchild=0;\t\tHT[i].rchild=0;\t}\tfor(i=1; i&lt;=n; i++)\t\tHT[i].weight = CH.letter[i].count;\t\t\tfor(i=n+1; i&lt;=m; i++)\t{\t\tint s1, s2;\t\tSelect(HT, i-1, s1, s2);\t\tHT[s1].parent=i; HT[s2].parent=i;\t\tHT[i].lchild=s1; HT[i].rchild=s2;\t\tHT[i].weight = HT[s1].weight+HT[s2].weight;\t}}void Select(HuffmanTree HT, int len, int &amp;s1, int &amp;s2){\tint i=1;\twhile(HT[i].parent) i++;  //找到HT中首个无双亲的元素下标\ts1=i;\tfor(i=s1+1; i&lt;=len; i++)\t\tif(!HT[i].parent &amp;&amp; HT[i].weight&lt;HT[s1].weight) s1=i;\tHT[s1].parent=1;  //将1双亲暂时赋值1，为了避免s1与s2相同 \ti=1;\twhile(HT[i].parent) i++;\ts2=i;\tfor(i=s2+1; i&lt;=len; i++)\t\tif(!HT[i].parent &amp;&amp; HT[i].weight&lt;HT[s2].weight) \t\t\ts2=i;   \tHT[s1].parent=0;  //将s1双亲重新赋值0}void printHuffmanTree(HuffmanTree HT, int n){\tint i;\tfor(i=1; i&lt;=n; i++)\t\tprintf(\"%d %d %d %d %d\\n\",i, HT[i].weight, HT[i].parent, HT[i].lchild, HT[i].rchild);}void CreateHuffmanCode(HuffmanTree HT, HuffmanCode &amp;HC, int n){\tHC=new char*[n+1];  //分配存储n个字符编码的编码表空间 \tchar *cd=new char[n];  //分配临时存放每个字符编码的动态数组空间 \tcd[n-1]='\\0';  //编码结束符 \tint i;\tfor(i=1; i&lt;=n; i++)  //逐个字符求哈夫曼编码 \t{\t\tint start=n-1;  //start开始指向最后 \t\tint c=i, f=HT[i].parent;  //f指向结点c的双亲结点 \t\twhile(f)  //从叶子节点开始向上回溯，直到根结点 \t\t{\t\t\t--start;  //回溯一次start向前指一个位置 \t\t\tif(HT[f].lchild==c) cd[start]='0';  //结点c是f的左孩子，则生成代码0 \t\t\telse cd[start]='1';  //结点c是f的右孩子，则生成代码1 \t\t\tc=f; f=HT[f].parent;  //继续向上回溯 \t\t}\t\tHC[i]=new char[n-start];  //为第i个字符编码分配空间 \t\tstrcpy(HC[i], &amp;cd[start]);  //将求得的编码从临时空间cd复制到HC的当前行中 \t}\t}void printEncode(HuffmanCode HC, char str[], LTList CH, char encode[]){\tint i=0;\twhile(str[i]!='\\0')  //遍历每个字母，在LTList中找到对应字母下标，根据下标在HC中定位下标，输出编码 \t{\t\tint temp=1;\t\twhile(CH.letter[temp].c!=str[i]) temp++;\t\tprintf(\"%s\", HC[temp]);\t\tstrcat(encode, HC[temp]);  //将译码粘到encode里 \t\ti++;\t}}void printDecode(HuffmanCode HC, char encode[], LTList CH)  //译码{\tchar *p=encode; //p指向编码首部 \twhile(p[0]!='\\0')  //将所有编码译码 \t{\t\tint i=1;\t\tchar code[CH.length];\t\tstrncpy(code, p, i);\t\tcode[i]='\\0'; \t\tint subcript;  //用以记录该编码对应字母的下标 \t\twhile(!find_code(code, HC, subcript, CH.length))  \t\t{\t\t\ti++;  //增加一位 \t\t\tstrncpy(code, p, i);\t\t\tcode[i]='\\0';\t\t}\t\tprintf(\"%c\", CH.letter[subcript].c);\t\tp=p+i;  //使p指向当前未判断的编码的首部 \t}}Status find_code(char code[], HuffmanCode HC, int &amp;subscript, int len){\tfor(subscript=1; subscript&lt;=len; subscript++)\t{\t\tif(strcmp(code, HC[subscript])==0) return OK;\t}\treturn 0;}"
  },
  
  {
    "title": "c语言程序设计-万年历",
    "url": "/posts/c%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-%E4%B8%87%E5%B9%B4%E5%8E%86/",
    "categories": "",
    "tags": "",
    "date": "2023-06-25 15:02:00 +0800",
    





    
    "snippet": "万年历分析设计（1）根据输入的年份，在屏幕上输出该年的日历。（2）根据输入的年月信息，在屏幕上输出该月的日历。（3）根据输入的年月日信息，计算距今天还有多少天，星期几，是否是节日。（4）输出年历时，以月份和星期做表头。（5）系统以菜单方式工作。（6）优化用户界面，使其更加具有粘合度。需求分析程序的用途：此程序适用于所有人，为用户提供了查询日历，计算日期时间的功能，解决了查询日期不方便的问题。...",
    "content": "万年历分析设计（1）根据输入的年份，在屏幕上输出该年的日历。（2）根据输入的年月信息，在屏幕上输出该月的日历。（3）根据输入的年月日信息，计算距今天还有多少天，星期几，是否是节日。（4）输出年历时，以月份和星期做表头。（5）系统以菜单方式工作。（6）优化用户界面，使其更加具有粘合度。需求分析程序的用途：此程序适用于所有人，为用户提供了查询日历，计算日期时间的功能，解决了查询日期不方便的问题。程序要处理的数据有用户输入的数据，闰年的计算，和节日的数据，用户输入数据要求要准确并且要设定一定的范围值，防止数据过大。#include &lt;stdio.h&gt;#include &lt;math.h&gt;#include &lt;string.h&gt;#include \"time.h\" int nowyear(){ //获取系统的年份     \ttime_t rawtime; \tstruct tm * timeinfo; \ttime ( &amp;rawtime ); \ttimeinfo = localtime ( &amp;rawtime );\treturn( timeinfo-&gt;tm_year+1900) ;   } \tvoid happy(int month,int day){ //节假日查询 \tprintf(\"\\t\\t\\t***********************************************\\n\");\tprintf(\"\\n\\t\\t\\t\"); \tif(month==1&amp;&amp;day==1) printf(\"您所查询的日期为元旦节，祝您元旦节快乐\");\tif(month==1&amp;&amp;day==6) printf(\"您所查询的日期为小寒，请注意保暖\");\tif(month==1&amp;&amp;day==20) printf(\"您所查询的日期为大寒，请注意保暖\"); \tif(month==2&amp;&amp;day==4) printf(\"您所查询的日期为立春，请注意保暖\");\tif(month==2&amp;&amp;day==14) printf(\"您所查询的日期为情人节，请注意保护单身狗\");\tif(month==3&amp;&amp;day==5) printf(\"您所查询的日期为惊蛰，多喝热水\");\tif(month==3&amp;&amp;day==8) printf(\"您所查询的日期为妇女节，多喝热水\");\tif(month==3&amp;&amp;day==12) printf(\"您所查询的日期为植树节，蚂蚁森林也能种树哦\");\tif(month==3&amp;&amp;day==20) printf(\"您所查询的日期为春分，多出去走走享受生活\");\tif(month==4&amp;&amp;day==1) printf(\"您所查询的日期为愚人节，请小心你身边的伙伴\");\tif(month==4&amp;&amp;day==4) printf(\"您所查询的日期为清明节，踏青春游正在路上\");\tif(month==4&amp;&amp;day==19) printf(\"您所查询的日期为谷雨，多喝热水\");\tif(month==5&amp;&amp;day==1) printf(\"您所查询的日期为劳动节，今年的劳动节您准备去哪里玩呢？\");\tif(month==5&amp;&amp;day==4) printf(\"您所查询的日期为五四青年节，五四精神永远存在青年心中\");\tif(month==5&amp;&amp;day==20) printf(\"您所查询的日期为小满，天气转热要多注意\");\tif(month==6&amp;&amp;day==1) printf(\"您所查询的日期为儿童节，身边的孩子有没有更可爱呢？\");\tif(month==6&amp;&amp;day==21) printf(\"您所查询的日期为夏至，我要一大早醒来爱你一整天\");\tif(month==7&amp;&amp;day==1) printf(\"您所查询的日期为建党节，没有共产党就没有新中国\");\tif(month==7&amp;&amp;day==6) printf(\"您所查询的日期为小暑，请注意避暑\");\tif(month==7&amp;&amp;day==22) printf(\"您所查询的日期为大暑，也要出去运动注意湿气哦\");\tif(month==8&amp;&amp;day==1) printf(\"您所查询的日期为建军节，听党指挥能打胜仗作风优良\");\tif(month==8&amp;&amp;day==7) printf(\"您所查询的日期为立秋，今天有没有想我啊\");\tif(month==8&amp;&amp;day==22) printf(\"您所查询的日期为处暑，天气开始转凉，要注意身体哦\");\tif(month==9&amp;&amp;day==1) printf(\"就要开学了，你兴奋吗！\");\tif(month==9&amp;&amp;day==7) printf(\"您所查询的日期为白露，蒹葭苍苍,白露为霜\") ; \tif(month==9&amp;&amp;day==10) printf(\"您所查询的日期为教师节，今天向老师问好了吗\");\tif(month==9&amp;&amp;day==22) printf(\"您所查询的日期为秋分，多喝热水\");\tif(month==10&amp;&amp;day==1) printf(\"您所查询的日期为国庆节，我为我的祖国自豪\");\tif(month==10&amp;&amp;day==8) printf(\"您所查询的日期为寒露，天气渐冷，注意穿衣\");\tif(month==10&amp;&amp;day==23) printf(\"您所查询的日期为霜降，注意穿衣\");\tif(month==11&amp;&amp;day==7) printf(\"您所查询的日期为立冬，今天立冬了，你爱的人在哪里呢\");\tif(month==12&amp;&amp;day==7) printf(\"您所查询的日期为大雪，今天的郑州下雪了吗\");\tif(month==12&amp;&amp;day==21) printf(\"您所查询的日期为冬至，圣源餐厅的饺子今天什么馅的啊\"); } void searchhead(int year,int month){\t\t\t//月历的表头 \tprintf(\"\\t%d年%d月\\n\",year,month);\tprintf(\"\\t***************************************************\\n\")\t;\tprintf(\"\\t日\\t一\\t二\\t三\\t四\\t五\\t六\\n\"); }int leapyear(int year){\t\t\t//判断是否为闰年\tif(year%4==0&amp;&amp;year%100!=0||year%4==0&amp;&amp;year%400==0) return 1;         else return 0;\t} int monthnum(int year,int month){\t\t\t//返回月份多少天 \tint a1[13]={0,31,28,31,30,31,30,31,31,30,31,30,31};\tint a2[13]={0,31,29,31,30,31,30,31,31,30,31,30,31}; \tif(leapyear(year)==1) return a2[month]; \telse return a1[month];}    int  week(int year,int month,int day){\t\t\t//根据蔡勒公式计算星期几 \tint w ,c,y;    if(month==1){ \t\tmonth=13; \t\tyear=year-1; \t}    if(month==2){ \t\tmonth=14; \t\tyear=year-1; \t} \ty=year%100; \tc=(year/1000)*10+(year/100%10); \tif(y==0) c=c-1; \tw=y+floor(y/4)+floor(c/4)-2*c+floor(26*(month+1)/10.0)+day-1;\twhile(w&lt;0)\t\tw=w+7;    if(w%7==0) \t\treturn(7);\treturn(w%7);}int nowmonth() {   //获取系统的月份\ttime_t rawtime; \tstruct tm * timeinfo; \ttime ( &amp;rawtime ); \ttimeinfo = localtime ( &amp;rawtime );\treturn(timeinfo-&gt;tm_mon+1  ) ;\t}int sum(int year, int month, int day){    //计算一个时间点到公元一年一月一日的天数     int mon[] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};    int sum = (year - 1) * 365;  //自从公元一年来的天数     int i;    sum += (year - 1) / 4 + 1;  //能被四整除的加上1     sum -= (year - 1) / 100 + 1;  //其中被100整除的不是闰年     sum += (year - 1) / 400 + 1;  //实际上能被400整除的即为闰年     for(i = 0; i &lt; month - 1; ++i)  //将本年剩下的整月加上        sum += mon[i];    if(leapyear(year) == 1 &amp;&amp; month &gt; 2)  //本年是否为闰2月        ++sum;    sum += day;  //本月的日子加上      return sum;}void copy(int year,int month) { //打印日历 \tprintf(\"\\n\");\tint k,i,j,spacenum,count;\tsearchhead(year,month)\t;//获取表头 \tspacenum=week(year,month,1);//计算星期几 \tif(spacenum!=7)\t\t\t//输出空格 第一位数字 \t \tfor(i=1;i&lt;=spacenum;i++)\t \t\tprintf(\"\\t \");\t\tcount=spacenum;\tfor(i=1;i&lt;=monthnum(year,month);i++){ //打印日历 \t\tprintf(\"\\t%d \",i);\t \tcount++;\t \tif(count%7==0)\t \t \tprintf(\"\\n\");\t}\tprintf(\"\\n\");}int function1(){\tint k,i,j,spacenum,count;\tprintf(\"-----查看当年年历或当月月历-----\\n\\n\");\tprintf(\"\\t您想查看今年的年历还是当月的月历,请输入1【年历】或0【月历】:\");\tscanf(\"%d\",&amp;k);\tprintf(\"\\n\");\tif(k==0) \t copy(nowyear(),nowmonth());    if(k==1)  \t\tfor(j=1;j&lt;=12;j++)  \t\t\t copy(nowyear(),j);}int function2(){\tint year,month,j;    printf(\"-----搜素某年的年历或某月的日历-----\\n\\n\");    printf(\"\\t请输入您所想查看的年份：\");    scanf(\"%d\",&amp;year);    if(year&gt;=99999||year&lt;=0)     {printf(\"你的输入错误。\");\t}\telse{\t    printf(\"\\t请输入您所想查看的月份（如果想查看整年日历请输入'0'）：\");\tscanf(\"%d\",&amp;month);     if(month!=0) \t\tcopy(year,month);    if(month==0)  \t\tfor(j=1;j&lt;=12;j++)  \t\t\tcopy(year,j);\t\t\t  }}int function3(){\ttime_t timep;\tstruct tm *p;\ttime(&amp;timep);\tp = gmtime(&amp;timep);\tint year,month,day,baby,sign;\tint a,b,c,x,y,z;\tprintf(\"\\n\\n\\n\\t\\t\\t********************************************************************\\n\"); \tprintf(\"\\n\\t\\t\\t如果您需要计算距离本日时间请输入0，如果是需要计算两个日子时间请输入1:\"); \tscanf(\"%d\",&amp;sign);\tif(!sign){\t\tprintf(\"\\n\\n\\t\\t\\t*****************************\\n\"); \t\tprintf(\"\\n\\t\\t\\t请输入您所需要计算的年份:\");\t\tscanf(\"%d\",&amp;year);\t\tprintf(\"\\n\\n\\t\\t\\t***************************\\n\"); \t\tprintf(\"\\n\\t\\t\\t请输入您所需要计算的月份:\");\t\tscanf(\"%d\",&amp;month);\t\tprintf(\"\\n\\n\\t\\t\\t***************************\\n\"); \t\tprintf(\"\\n\\t\\t\\t请输入您所需要计算的日份:\");\t\tscanf(\"%d\",&amp;day);\t\tbaby = sum(nowyear(),nowmonth(),p-&gt;tm_mday)-sum(year,month,day);\t\tbaby=fabs(baby);\t\tprintf(\"\\n\\n\\t\\t\\t据今天有%d天\",baby);\t\tprintf(\"，而且您所查询的日期为星期%d！\\n\\n\",week(year,month,day));\t\thappy(month,day); \t\t\t}\telse{\t\tprintf(\"\\n\\n\\t\\t\\t***********************************\\n\"); \t\tprintf(\"\\n\\t\\t\\t请输入您所需要计算第一个的年份:\");\t\tscanf(\"%d\",&amp;a);\t\tprintf(\"\\n\\n\\t\\t\\t********************************\\n\"); \t\tprintf(\"\\n\\t\\t\\t请输入您所需要计算第一个的月份:\");\t\tscanf(\"%d\",&amp;b);\t\tprintf(\"\\n\\n\\t\\t\\t********************************\\n\"); \t\tprintf(\"\\n\\t\\t\\t请输入您所需要计算第一个的日份:\");\t\tscanf(\"%d\",&amp;c);\t\tprintf(\"\\n\\n\\t\\t\\t**********************************\\n\"); \t\tprintf(\"\\n\\t\\t\\t请输入您所需要计算第二个的年份:\");\t\tscanf(\"%d\",&amp;x); \t\tprintf(\"\\n\\n\\t\\t\\t********************************\\n\"); \t\tprintf(\"\\n\\t\\t\\t请输入您所需要计算第二个的月份:\");\t\tscanf(\"%d\",&amp;y);\t\tprintf(\"\\n\\n\\t\\t\\t********************************\\n\"); \t\tprintf(\"\\n\\t\\t\\t请输入您所需要计算第二个的日份:\");\t\tscanf(\"%d\",&amp;z);\t\tbaby=sum(x,y,z)-sum(a,b,c);\t\tbaby=fabs(baby);\t\tprintf(\"\\n\\n\\t\\t\\t********************\"); \t\tprintf(\"\\n\\n\\t\\t\\t两个日期相差有%d天\",baby);\t}\t}int head(){\tint select; \tprintf(\"\\n\\n\\n\\n\\n\\n\\n\"); \tprintf(\"\\t\\t\\t\\t\\t    &lt;--欢迎使用万年历--&gt;\\n\\n\"); \tprintf(\"\\t\\t\\t\\t       ****************************************\\n\");\tprintf(\"\\t\\t\\t\\t       请选择要使用的功能：\\n\\n\");\tprintf(\"\\t\\t\\t\\t\\t       1.查看今年年历或当月月历\\n\");\tprintf(\"\\t\\t\\t\\t\\t       2.搜素某年的年历或某月的日历\\n\");\tprintf(\"\\t\\t\\t\\t\\t       3.查询历史上某日\\n\");\tprintf(\"\\t\\t\\t\\t\\t       4.退出\\n\");\tprintf(\"\\t\\t\\t\\t       ****************************************\\n\"); \tprintf(\"\\t\\t\\t\\t\\t       请选择&lt;1,2,3,4&gt;：\");  \tscanf(\"%d\",&amp;select) ;\tprintf(\"\\n\");\treturn select;} int frist(){\tprintf(\"\\n\\t\\t\\t\\tWelcome to use the calendar made by Mr.cao\\n\");\tprintf(\"\\n\\t\\t\\t\\tThanks to the teacher for teaching over the past half semester\\n\");\t }int main(){\tint select; \tchar ch; \tfrist();\twhile(1){\t\tselect=head();\t\tif(select==1)\t\t\tfunction1();\t\tif(select==2)\t\t\tfunction2();\t\tif(select==3)\t\t\tfunction3();\t\tif(select==4)\t\t\tbreak;\t\t\t} }"
  },
  
  {
    "title": "绕过校园网问题",
    "url": "/posts/%E7%BB%95%E8%BF%87%E6%A0%A1%E5%9B%AD%E7%BD%91%E9%97%AE%E9%A2%98/",
    "categories": "心得",
    "tags": "校园网",
    "date": "2023-06-14 14:36:00 +0800",
    





    
    "snippet": "前言校园网真是个神奇的东西，超高的网费带来的还是极差的体验，很多学校的校园网不仅设有仅仅 1~2 台登录设备限制，其客户端还各种千方百计阻拦你开热点，实在是令人痛不欲生。本 up 坐标广东某学校，目前的校园网新由电信代理，使用的客户端是广东天翼校园，是今年才刚刚换装全新的使用的，具有网页客户端双重验证，且同时在线设备数仅为 1 台，极其令人反胃，而且速度感人，晚上还断网，简直了。目前大部分所...",
    "content": "前言校园网真是个神奇的东西，超高的网费带来的还是极差的体验，很多学校的校园网不仅设有仅仅 1~2 台登录设备限制，其客户端还各种千方百计阻拦你开热点，实在是令人痛不欲生。本 up 坐标广东某学校，目前的校园网新由电信代理，使用的客户端是广东天翼校园，是今年才刚刚换装全新的使用的，具有网页客户端双重验证，且同时在线设备数仅为 1 台，极其令人反胃，而且速度感人，晚上还断网，简直了。目前大部分所谓说可以过校园网的软件都是已经失效的，甚至已经变成广告流氓程序（比如猎豹 wifi 之类的），大家可以试试，但要做好防毒措施。在如此严峻的情况下，我还是给大家总结了几种至少在我这里可以使用的开热点的方法，希望能给各位饱受校园网垄断的广大苦逼学生党们一点思路。虚拟机万能法虚拟机 + 外置无线网卡的组合，基本上是可以通杀所有网络限制的，哪怕是某些需要进行严格网络审计的内网，这种方法也可以绕过网络检测。只是用来绕一个校园网的开热点限制的话，只能说是万能但相对浪费资源。不推荐使用内置无线网卡，有几率会被检测出，具体情况自行测试。你需要准备的东西有：虚拟机程序用于虚拟机的系统镜像外置的无线网卡和驱动一个网络热点生成程序一双手虚拟机配置这里我们推荐使用 VMWare 虚拟机进行操作。其他虚拟机自行摸索即可，换汤不换药。首先下载一个 VMWare 虚拟机，版本不限（最好 &gt; 10.0)，可自己找资源下，图省事的可以直接用我整理好的，链接会放在此章结尾。这里我以 15.5 版本演示。然后下载一个系统镜像，建议选择 windows7 或者 windows10，windows7 系统更加精简，省资源，电脑配置不高的同学可以选择，缺点是兼容性不好，而且需要自己打上无线网卡的驱动。这里推荐两个下载镜像的网站：山己几子木：https://msdn.sjjzm.com/MSDN I TELL YOU : https://msdn.itellyou.cn/不想折腾的同学也可以用我整理的两个系统镜像，这里我选择 windows10 进行演示。系统安装过程很简单，不会的可以自己找教程，这是安装好后虚拟机的界面。网络热点配置首先，在开启虚拟机后，插入你的无线网卡。（如果已经插上了，请拔出来重新插一次），会看到虚拟机的提示：如图操作，选择确定即可。如果没有看到弹窗，请手动添加网卡设备到虚拟机中windows10 自带无线网卡驱动，当然如果你想获得更稳定的体验，可以下载厂家提供的驱动。windows7 不可省略驱动安装步骤。下面基本就可以直接开热点了，系统自带的热点经过测试有可能出现无网络或者开启失败的情况，为了最稳定的体验，我建议安装一个热点分享程序。我这里选择的是 WIFI 共享大师， 纯流氓程序一个，但是能比较好的适配大多数虚拟机的热点开启情况，我这里准备了原版和去流氓版的 WIFI 共享大师，大家可以都下来试试（反正虚拟机不怕死）现在就基本可以稳定开启热点了。如果连上 WIFI 后发现部分网页 APP 无网络的情况，可以尝试在手机上修改 DNS 为 223.5.5.5 或 114.114.114.114用到的虚拟机和镜像等文件：https://cloud.189.cn/t/Nv6jIbZZZBbu (访问码:ei5h)旧版本客户端不少校园网登陆器都经历了十几年的风雨，旧版本客户端很多时候审查不严，可以使用删后台大法绕过热点检查。up 用的是广东天翼校园，如果你也是用这个登录器，可以试试这个旧版本的天翼校园，经过简单的删后台操作即可。第一步，先卸载原本的天翼校园，安装旧版天翼校园，正常登录。第二步，打开任务管理器，直接结束进程即可开启热点。此方法十分简单，但是局限性很大，断网不稳定概率高，能否找到能用的旧版登陆器只能看看你们的学长给不给力了。旧版本天翼校园：https://cloud.189.cn/t/quUnU3ANZvmm (访问码:j8dl)第三方登陆器有很多大佬自制的第三方登陆器，可以替代原先的校园网登录程序，不受原校园网登录器的限制，这种方法比较适合高技术力的同学尝试，这里我贴上我们学校一位大佬开发的第三方天翼校园登陆器 EAuthenticator。第三方登陆器大多都需要自己填写 nasip, 每个学校的校园网认证地址都是不相同的，寻找自己学校的 nasip 地址很简单，作者提供了两种方法：断网时会自动打开一个网页， 上面会有天翼校园的客户端下载。此时查看网址，” &amp;wlanacip= “ 后面的 IP 地址即为 nasip。右键你的天箅校园客户端，打开文件位置，找到 Config 文件夹，打开 ConnectSetting.ini 文件，wlanacip 后面的 IP 地址即为 nasip使用第三方登陆器不仅连接更稳定，而且不受网络限制，如果有合适的第三方登陆器，应该是上校园网最舒服的方法。Github 项目地址：https://github.com/PandaAdap/EAuthenticator/releases热点限制补丁推荐一个很强大的小工具 EShare Tool，可以干掉原校园网客户端的热点限制，不局限于天翼校园，使用方法很简单，一键操作，永久有效。Github 项目地址：https://github.com/PandaAdap/EShareTool/releases无脑操作，一键起飞，通杀市面上 90% 的客户端，缺点是挑电脑，不是每台电脑都能有效跑起来。（还有不少类似的小工具，大伙都可以去找找）端口绕行此方法如果成功，可以直接让你省下四年校园网费，就不仅仅是开个热点这么简单了。原理：部分认证设备没有屏蔽 53，67，68 等等端口，可通过这些端口建立 VPN 连接将流量转发出去。就算所有端口屏蔽了，如果启用了 IPV6，那么能通过 IPV6 VPN 服务器转发流量。  测试 53DNS 端口是否放通控制面板打开网络属性，发现 DNS 为外部 114DNS。开启 CMD 输入：ping baidu.com 如图可以获得 IP 地址 220.181.38.251 但无法 ping 通。说明认证设备开放了 53 端口【为了通过 114dns 获取认证页面地址】，并且屏蔽了其它端口导致不能 ping 通。出现这种情况，那么恭喜你此方法是有可行性的。  安装 OPENVPN 服务器 [Windows]SoftEther 下载中心 (fishinfo.cn) 下载并安装【server】如果是在本地服务器上连接并配置，则安装 server 后可以直接进入控制台如果是远程管理服务端，则需要输入服务器公网 IP 端口【默认 443】，默认无密码如图连接(1). 添加用户新建用户(2). 开启 NAT(3). 设置端口并导出配置文件把默认的 1194 端口改为 53 或 67 或 68 等等，如果不行多次尝试先设置端口再生成配置文件下载并编辑 xxx_openvpn_remote_access_l3.ovpn需要配置地址和端口 按照实际情况来看。  客户端连接客户端下载地址：OpenVPN Connect Client | Our Official VPN Client | OpenVPN最后双击刚刚保存的配置文件，按照提示导入，输入账户，连接并输入密码就成功启动了如果连接超时，正常网络下却能连接，那么很可能是 53 端口未开放，需要换个端口试试已知问题：部分系统在连接成功一段时间后会无响应，此时流量显示 0kb，这时候需要重启软件伪装已认证设备  下载相关局域网扫描软件网络扫描软件：Advanced port scanner 官网下载地址: 点击打开MAC 地址修改软件: 天天修改器 - 蓝凑云  扫描局域网输入网段 IP，可以在控制面板查看Tips: 对于大型公共网络，网段可能不止一个，如图我的网段是 180-183 都有设备  复制 IP 地址，MAC 地址操作之前先去控制面板记录下原来的信息最好先断开网络进行操作，完成后再连接  修改 MAC 地址随机找个幸运设备吧 [doge]复制它的 MAC 地址打开 MAC 地址修改工具，选择当前使用的网卡，修改 [部分修改器不自动重载网卡，无法立刻生效修改内容，需要手动重载]  修改 IP 地址打开控制面板如图操作，输入刚刚复制的 IP 地址，子网掩码自动生成，默认网关输入刚刚记下的完成后保存，测试网络连接在这里放一个安卓端的客户端：https://wwa.lanzoui.com/iqncOwlwt1a 需要自取爆破校园网后台找到上面扫描的局域网信息从第一个设备开始点过去，找 http 服务，即管理后台地址一般是第一个设备 [网关]打开后台就是凑密码了，谷歌：看到的设备型号 + 默认密码如果你运气够好，进入后就不必说了，增加个用户，起飞啦！IPv6 流量转发偷跑可以通过这个网站测试一下你的网络是否支持 IPv6 连接：http://www.test-ipv6.com由于本人所在的校园网环境不支持 IPv6 ，所以就放弃了。不排除是我 DNS 设置的问题。该方法较为复杂，需要涉及到 ss 代理 和一台高带宽的服务器进行流量转发（使用带 ipv6 功能的路由器，转发家用带宽理论也是可行的），一般不推荐个人搭建，成本过高，但是有不少所谓的校园网免流商家干这个，如果价格合适可以买一个月试试。刷路由器固件如果你有这个想法，那么恭喜你，你已经是一名准垃圾佬了。有兴趣的建议网上搜教程视频看，我反正是折腾了一个星期终于折腾出来了，然后发现还是直接用第三方校园网舒服哈哈哈哈哈本方法耗时耗力，适合有兴趣折腾硬件的同学尝试。不要买淘宝上那些所谓的校园网路由器，P 都不是，低质高价专嘎新生韭菜！！！"
  },
  
  {
    "title": "关注我",
    "url": "/posts/%E5%85%B3%E6%B3%A8%E6%88%91/",
    "categories": "",
    "tags": "",
    "date": "2023-06-13 22:59:00 +0800",
    





    
    "snippet": "微信公众号获取chatgpt",
    "content": "微信公众号获取chatgpt"
  },
  
  {
    "title": "wx-03，表单-弹框，request，页面管理，tabbar，onshow",
    "url": "/posts/wx-03-%E8%A1%A8%E5%8D%95-%E5%BC%B9%E6%A1%86-request-%E9%A1%B5%E9%9D%A2%E7%AE%A1%E7%90%86-tabbar-onshow/",
    "categories": "实训-微信小程序",
    "tags": "课程, 微信小程序",
    "date": "2023-06-13 22:22:00 +0800",
    





    
    "snippet": "1，表单1，input使用input默认宽度100%，没有边框。重要属性1，value，默认值2，type，输入框类型3，password，是否是密码类型重要事件1，bindinput，输入改变触发input与data双向绑定+———————————————————————–+| &lt;input model:value=”” /&gt;                          ...",
    "content": "1，表单1，input使用input默认宽度100%，没有边框。重要属性1，value，默认值2，type，输入框类型3，password，是否是密码类型重要事件1，bindinput，输入改变触发input与data双向绑定+———————————————————————–+| &lt;input model:value=”” /&gt;                                     ||                                                                       ||                                                                |+———————————————————————–+| Page({                                                                ||                                                                       || data:{                                                                ||                                                                       || age:78                                                                ||                                                                       || }                                                                     ||                                                                       || })                                                                    |+———————————————————————–+2，checkbox复选框多选项目，注意配合label使用，常用属性：1，value，复选框的值2，color，复选框颜色，同css3，checked，是否默认选中&lt;checkbox value=\"apple\" checked=\"true\"color=\"#00f\"&gt;&lt;/checkbox&gt;若要获得checkbox的值，需要配合：checkbox-group3，checkbox-group - 多项选择器多项选择器，内部由多个checkbox组成，可轻松获得checkbox选择的数组。常用属性：1，bindchange当内部的checkbox改变时，选中的checkbox的值，会以数组的形式，保存在回调函数参数中的detail.value中+———————————————————————–+| &lt;checkbox-group bindchange=\"tap1\"&gt;                                ||                                                                       || &lt;checkbox value=\"apple\"&gt;&lt;/checkbox&gt;                             ||                                                                       || &lt;checkbox value=\"pare\"&gt;&lt;/checkbox&gt;                              ||                                                                       || &lt;/checkbox-group&gt;                                                   |+———————————————————————–+| tap1(r){                                                              ||                                                                       || console.log(r.detail.value);                                          ||                                                                       || }                                                                     |+———————————————————————–+4，label标签改进表单的可用性，使用for属性找到对应的表单id，或者将控件放在该标签下，当点击时，就会触发对应的控件。可绑定的控件有：checkbox也可以当做普通的行内元素使用2，弹框1，showToast提示消息提示框，类似layui的msg，默认1.5秒后自动消失，常用属性有：1，title，提示内容2，icon，提示图标，success/loading/none3，image，自定义图标的本地路径，image 的优先级高于 icon4，duration，提示的延迟时间5，mask，是否显示透明蒙层，防止触摸穿透+———————————————————————–+| wx.showToast({                                                        ||                                                                       || title:\"4455\",                                                       ||                                                                       || icon:\"loading\",                                                     ||                                                                       || image:\"../../img/cat.jpg\",                                          ||                                                                       || mask:true                                                             ||                                                                       || })                                                                    |+———————————————————————–+2，showLoading加载动画加载提示框，类似layui的load，需要主动关闭，hideLoading关闭加载动画。常用属性有：1，title，提示内容2，mask，是否显示透明蒙层，防止触摸穿透+———————————————————————–+| wx.showToast({                                                        ||                                                                       || title:\"4455\",                                                       ||                                                                       || icon:\"loading\",                                                     ||                                                                       || image:\"../../img/cat.jpg\",                                          ||                                                                       || mask:true                                                             ||                                                                       || })                                                                    |+———————————————————————–+| //hideLoading关闭动画                                                 ||                                                                       || wx.hideLoading();                                                     |+———————————————————————–+3，showModal模态框警告确认框显示模态对话框，类似js的alert和confim，常用属性如下：1，title，提示标题2，content，提示内容3，showCancel，显示取消按钮4，cancelText，取消按钮内容5，confirmText，确认按钮内容6，success，点击确认/取消后的回调，接受参数r1）若r.confirm为true，点击了确认按钮2）若r.cancel为true，点击了取消按钮例如：+———————————————————————–+| wx.showModal({                                                        ||                                                                       || title:\"4455\",                                                       ||                                                                       || content:\"999\",                                                      ||                                                                       || success (r){                                                          ||                                                                       || console.log(r)                                                        ||                                                                       || }                                                                     ||                                                                       || })                                                                    |+———————————————————————–+3，调用ajax数据1，调用ajax数据 - 概述小程序调用ajax数据，是需要在小程序后台设置域名白名单的，但是也可以绕过白名单限制，模拟线上接口调用。2，绕过域名白名单限制在小程序开发ide中，依次进行如下操作：详情 - 本地设置 - 勾选【不校验本地域名】{width=”2.907638888888889in” height=”3.11875in”}3，request - 发起ajax请求具体参考官方文档：开发 - api - 网络 - 发起请求发送formdata请求：+———————————————————————–+| header: {                                                             ||                                                                       || 'content-type': 'application/x-www-form-urlencoded'               || //修改此处即可                                                        ||                                                                       || },                                                                    |+———————————————————————–+4，页面管理1，页面概述小程序中，每个页面由4个文件组成：1，页面名.js，页面js逻辑处理，例如生命周期，调用函数，初始化数据2，页面名.json，类似app.json，只是他只针对当前页面，优先级大于app.json3，页面名.wxml，存放页面的dom结构4，页面名.wxss，存放当前页面的样式2，新建页面由于每个页面都由4个文件组成，所以为了方便管理，建议把每个页面的文件，单独放在一个文件夹中，文件夹可根据需求随意嵌套。下面以新建help页面为例，注意，新建页面建议在小程序ide中进行，因为他会自动帮我们生成所有文件：1，在pages目录下新建文件夹help（建议目录名和页面名保持一致）2，右键单击目录，新建page，输入help即可（自动生成4个文件）页面新增后，会自动在app.json下的pages字段中，生成一个数组元素。3，新建页面的效果{width=”2.795138888888889in”height=”2.326388888888889in”}5，tabbar1，tabBar概述tabbar就是小程序底部的tab导航切换，在app.json中进行配置。参考文档位置：开发 - 框架 - 小程序配置 - 全局配置小程序底部、顶部可以设置tab切换，最多5个，最少2个。常用属性：1，tabBar，tab 上的文字默认颜色2，selectedColor，tab 上的文字选中时的颜色3，backgroundColor，tab 的背景色4，list，tab 的列表2，tabBar.listlist是个数组，里面记录了底部的切换页面数组，注意，第一个元素必须是小程序的首页。每个页面常用属性如下：1，pagePath，页面路径，必须在 pages 中先定义2，text，tab 上按钮文字3，iconPath，图片路径4，selectedIconPath，选中时的图片路径6，onShow生命周期生命周期值得是页面从创建，到销毁的整个过程；onShow，用于监听页面的显示，当页面从隐藏变为显示时触发。例如：+———————————————————————–+| // index.js                                                           ||                                                                       || Page({                                                                ||                                                                       || onShow(){                                                             ||                                                                       || }                                                                     ||                                                                       || })                                                                    |+———————————————————————–+"
  },
  
  {
    "title": "wx-02，数据属性，函数事件，if-for，text，image，样式",
    "url": "/posts/wx-02-%E6%95%B0%E6%8D%AE%E5%B1%9E%E6%80%A7-%E5%87%BD%E6%95%B0%E4%BA%8B%E4%BB%B6-if-for-text-image-%E6%A0%B7%E5%BC%8F/",
    "categories": "实训-微信小程序",
    "tags": "课程, 微信小程序",
    "date": "2023-06-13 22:15:00 +0800",
    





    
    "snippet": "1，基础功能1，数据绑定js的data中声明变量，页面调用//wxml部分//js部分Page({data:{age:90，arr:[55,77,99]，cat:{num:3　　　　}}})2，属性绑定直接在属性中写data:{　age:5}//渲染结果：&lt;view id=”k5m”&gt;&lt;/view&gt;3，小程序的函数小程序的函数，直接在Page里写即可Page({dat...",
    "content": "1，基础功能1，数据绑定js的data中声明变量，页面调用//wxml部分//js部分Page({data:{age:90，arr:[55,77,99]，cat:{num:3　　　　}}})2，属性绑定直接在属性中写data:{　age:5}//渲染结果：&lt;view id=”k5m”&gt;&lt;/view&gt;3，小程序的函数小程序的函数，直接在Page里写即可Page({data:{age:89},//函数x1(){　　},　　x2:function(){　　}})2，触摸事件1，单击事件bindtap，手指触摸后马上离开，函数名后不可带小括号。//语法&lt;view bindtap=”函数名”&gt;111&lt;/view&gt;例如：&lt;view bindtap=”x1”&gt;111&lt;/view&gt;3，事件传参小程序事件传递参数，不同于前端开发，它采用事件对象的自定义属性的方式，所有参数，以事件对象形式，都放在事件发生者的dataset里。例如：//参数写死：&lt;view data-参数1=”77” data-参数2=”66” bindtap=”x1”&gt;按钮11&lt;/view&gt;//参数为变量&lt;view data-参数1=”” data-参数2=”66” bindtap=”x1”&gt;按钮11&lt;/view&gt;x1(e){var target = e.currentTarget.dataset;}3，操作datadata中的数据可读可写。例如：//定义data中的数据Page({age:7,　　arr:[5,2],　　obj:{　　a:6,　　b:7　　}})//函数读取data中的数据console.log(this.data.age);console.log(this.data.arr);console.log(this.data.obj);//修改、添加数据this.setData({age:88,//写单个变量　　“arr[0]”:89,//写数组第一个})//修改数组this.setData({　　”arr[0]”:89,//修改数组中的元素})//向数组中添加数据this.data.arr.push(“鲁迅”);//更新数组this.setData({arr:this.data.arr})小程序data中的对象，追加的属性，天生具有响应式，不需要类似vue中$set的设置4，基础语法1，wx:if条件渲染使用 wx:if=”” 来判断是否需要渲染该代码块，配合wx:else使用，可实现互斥效果例如：//字面量&lt;view wx:if=”true”&gt;牛顿&lt;/view&gt;//变量&lt;view wx:if=””&gt;牛顿&lt;/view&gt;//else鲁迅ps：对比和hidden属性的区别2，wx:for列表渲染wx:for 控制属性绑定一个数组，把数组渲染到页面上。例如：&lt;view wx:for=””&gt;  - &lt;/view&gt;参数解释：index，默认下标item，默认元素通过wx:for-index，wx:for-item可修改默认下表和元素&lt;view wx:for=”” wx:for-index=”index1” wx:for-item=”item1”&gt;  &lt;/view&gt;参数解释：index1，修改后的下标item1，修改后的元素3，wx:key唯一标识和vue类似，若以后要动态修改此数组，需要提供wx：key&lt;view wx:for=”” wx:key=”id”&gt;&lt;/view&gt;arr:[{id:1:name:”wsc1”},{id:2:name:”wsc2”},{id:3:name:”wsc3”}]5，组件1，text - 文本text类似html中的span，重要属性如下：1，space，是否显示连续空格2，user-select，节点是否可选择3，decode，是否解码（  &lt; &gt; &amp; '    ）年&lt;圣诞节手动滑    稽后2，image图片通过image，可以显示本地或者网路上的图片，若是本地图片，可以放在项目的任意目录下，路径写对即可。（行内块级元素）常用属性：1，src，图片路径2，mode，图片裁剪、缩放的模式1）scaleToFill（默认值），图片变形充满整个容器2）aspectFit，图片完全居中显示，上下，左右会有白边3）aspectFill，图片尽量全部显示，过长的部分将被裁切4）center，图片上下左右居中，不缩放，自动裁切6，控制样式1，class控制可以在中写入变量，或者三目运算符表达式，结果就是待渲染的class类名例如：//变量渲染&lt;view class=”c1 ”&gt;data:{xx:’c2’}//渲染结果&lt;view class=”c1 c2”&gt;//表达式渲染&lt;view class=”c1 ”&gt;data:{xx:true}//渲染结果&lt;view class=”c1 c2”&gt;2，rpx尺寸单位rpx是小程序推荐的长度尺寸单位，英文全称（responsive pixel），它规定小程序中，界面宽度为750rpx。可以理解为把屏幕横向分成了750份，不必关心屏幕分辨率的大小。"
  },
  
  {
    "title": "购物车-微信小程序",
    "url": "/posts/%E8%B4%AD%E7%89%A9%E8%BD%A6-%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F-1/",
    "categories": "实训-微信小程序",
    "tags": "课程, 微信小程序",
    "date": "2023-06-13 22:09:00 +0800",
    





    
    "snippet": "1，微信小程序1，概述{width=”2.2090277777777776in”height=”0.8041666666666667in”}微信小程序，小程序的一种，英文名Wechat MiniProgram，是一种不需要下载安装即可使用的应用，它实现了应用”触手可及”的梦想，用户扫一扫或搜一下即可打开应用。与之类似的还有支付宝小程序，百度小程序等2016-1-9，腾讯启动微信小程序研发项目...",
    "content": "1，微信小程序1，概述{width=”2.2090277777777776in”height=”0.8041666666666667in”}微信小程序，小程序的一种，英文名Wechat MiniProgram，是一种不需要下载安装即可使用的应用，它实现了应用”触手可及”的梦想，用户扫一扫或搜一下即可打开应用。与之类似的还有支付宝小程序，百度小程序等2016-1-9，腾讯启动微信小程序研发项目2017-1-9，正式发布小程序官方文档：https://developers.weixin.qq.com/miniprogram/dev/framework/2，小程序和h5可以简单理解为小程序是h5的加强版，但是核心思路还是h5，小程序的语法，和vue很相似。之所以说是加强版，是因为h5运行在微信app内部，通过和原生app的交互，实现调用摄像头，访问硬件等功能，这些功能有了微信，可以实现良好兼容性，只考虑微信环境即可。有些组件，会渲染为原生的native组件，所以性能上比h5更好。3，安装IDE{width=”1.0347222222222223in”height=”0.9583333333333334in”}微信小程序有自己的开发工具，去官网下载。1，下载在开发者文档下，选择工具，然后找到下载地址https://developers.weixin.qq.com/miniprogram/dev/devtools/devtools.html{width=”3.3048611111111112in”height=”1.4861111111111112in”}2，安装根据提示，一路下一步即可，安装完成，微信扫码登录。{width=”2.4069444444444446in”height=”2.8354166666666667in”}{width=”3.9291666666666667in”height=”2.9472222222222224in”}2，先在微信公众平台注册开发者账号（不注册也行，但是要发布程序必须注册）https://mp.weixin.qq.com/4，官方文档结构https://developers.weixin.qq.com/miniprogram/dev/framework/1，小程序入门指南2，框架和配置3，基础组件4，api调用5，工具的使用6，社区论坛2，创建项目1，创建项目开发者工具安装完成之后，就可以创建项目了。1，启动开发者工具2，选择：小程序&gt;添加3，可以输入自己的appid没有appid，点测试号4，选择一个空目录，点击创建即可不要出现中文{width=”4.4in” height=”2.982638888888889in”}若曾经创建过项目，也可选择导入项目2，编辑器界面简介1，模拟器，编辑器，调试器2，机型切换，显示比例，3，模拟网络，4G，wifi，2G4，资源管理器，折叠与展开5，切后台模拟小程序进入后台6，真机调试、预览，清缓存7，添加编译模式8，调试基础库，版本简介3，编辑器设置设置 -&gt; 通用设置，启动小程序设置页面1，保存自动编译2，快捷键，界面外观{width=”4.338888888888889in” height=”3.625in”}3，项目解构介绍1，项目目录{width=”1.99375in” height=”3.1465277777777776in”}1，pages，保存所有页面保存项目中的所有页面，每个页面放在单独文件夹中2，utils，存放公共js逻辑3，app.js、app.wxss、app.json小程序和vue非常类似，可以理解为app是所有页面的根组件，这三个文件，分别控制全局的js，样式和配置4，project.config.json保存编辑器的个性化配置，例如界面颜色、编译配置等等，当换了另外一台电脑重新安装工具的时候，不必重新配置。5，sitemap.json配置小程序被微信搜索到，有利于seo2，页面组成1，wxml，文档结构类似html，小程序有自己的标签，所以div，p并不适用2，wxss，样式类似css（兼容css），意味着我们依然可以用学过的css3，js，行为也就是javascript4，app.json1，基础参数小程序根目录下的 app.json 文件，用来对微信小程序进行全局配置。            //app.json  {     “pages”:[      “pages/index/index”,      “pages/logs/logs”     ],     “entryPagePath”: “pages/logs/logs”  }                  //参数解释  1，entryPagePath，小程序默认启动首页，非必填  2，pages，路由管理数组，  所有用到的页面，都要在这里列出来，若没有entryPagePath，默认把数组第一个元素当做主页，必填      2，window参数window参数，也是app.json的一部分，用于设置小程序的状态栏、导航条、标题、窗口背景色。            //app.json  {     “window”:{      “navigationBarBackgroundColor”: “#fff”,      “navigationBarTitleText”: “Weixin”,      “navigationBarTextStyle”:”black”     },  }                  //参数解释，具体参考官方文档  navigationBarBackgroundColor，导航栏背景颜色，如 #000000  navigationBarTitleText，导航栏标题文字内容  navigationBarTextStyle，导航栏标题颜色，仅支持 black  / white      5，常用组件1，view，视图容器view类似html里面的div，块级元素，宽度默认100%，可修改。例如：            &lt;view hover-class=”c1”&gt;林黛玉&lt;/view&gt;  1111  1111                  参数解释：  1，hover-class，指定按下去的样式类  2，hover-start-time，按住后多久出现点击态，单位  3，hover-stay-time，毫秒手指松开后点击态保留时间，单位毫秒      2，button，按钮尺寸，loading动画图标，禁用，微信开放能力，hover-class&lt;button type=\"primary\" disabled=”true”&gt;页面主操作 Normal&lt;/button&gt;3，组件公共属性所有组件都有以下属性：1，id2，class3，style4，data-*， 自定义属性，事件传参用的所有组件除了这些公共属性，还可以有各自定义的属性，具体参考各个组件的定义。"
  },
  
  {
    "title": "外卖项目软件工程报告",
    "url": "/posts/%E5%A4%96%E5%8D%96%E9%A1%B9%E7%9B%AE%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%8A%A5%E5%91%8A/",
    "categories": "软件工程",
    "tags": "课程, 报告",
    "date": "2023-06-09 14:04:00 +0800",
    





    
    "snippet": "第1章 绪论视频链接：视频链接代码链接：代码链接1.1项目开发背景随着互联网的快速发展和智能手机的普及，外卖行业在过去几年中经历了快速增长。越来越多的消费者选择通过手机应用程序点餐，并享受送货上门的便利。然而，目前市场上存在许多不同的外卖平台，导致消费者选择困难，同时给商家和骑手带来了管理上的挑战。传统的外卖平台存在以下问题：用户体验不佳：部分平台界面复杂，操作繁琐，导致用户体验不佳。订单管...",
    "content": "第1章 绪论视频链接：视频链接代码链接：代码链接1.1项目开发背景随着互联网的快速发展和智能手机的普及，外卖行业在过去几年中经历了快速增长。越来越多的消费者选择通过手机应用程序点餐，并享受送货上门的便利。然而，目前市场上存在许多不同的外卖平台，导致消费者选择困难，同时给商家和骑手带来了管理上的挑战。传统的外卖平台存在以下问题：用户体验不佳：部分平台界面复杂，操作繁琐，导致用户体验不佳。订单管理混乱：商家需要同时处理来自多个平台的订单，订单管理和调度变得困难。配送效率低下：骑手需要在不同的平台上接受订单，导致路线不合理、时间浪费和效率低下。基于以上问题，开发一个基于 Elm（一种函数式编程语言）的外卖项目可以解决这些挑战并提供更好的解决方案。1.2 项目开发目的和意义开发 Elm 外卖项目的目的是为了改善外卖行业的管理和用户体验，提供以下优势和意义：1.提升用户体验：通过简洁而直观的用户界面和流畅的操作，使消费者能够方便地浏览菜单、下订单和追踪配送状态，从而提升用户体验。2.整合订单管理：通过一个统一的平台，商家可以管理来自不同外卖平台的订单，避免订单混乱和漏单的问题，提高订单管理的效率。3.优化配送调度：基于智能算法和地理定位信息，项目可以合理规划配送路线，提高骑手的配送效率和订单完成率，减少配送时间和成本。4.数据统计和分析：项目可以收集和分析订单数据，为商家提供销售和经营数据的报告和洞察，帮助商家做出决策并改进经营策略。5.推广和市场竞争力：通过优化用户体验和提供高效的订单管理系统，商家可以提高品牌知名度和用户口碑，增强市场竞争力。第2章 系统需求分析为了开发出真正满足用户需求的软件产品，首先必须知道用户的需求。对软件需求的深入理解是软件开发工作获得成功的前提条件。需求分析的任务还不是确定系统怎样完成它的工作，而仅仅是确定系统必须完成哪些工作，也就是对目标系统提出完整、准确、清晰、具体的要求。2.1 系统功能需求\\1. 用户注册与登录：用户注册：允许用户创建新的账户并提供必要的个人信息。用户登录：允许已注册用户使用其凭据登录系统。\\2. 餐厅管理：餐厅入驻：允许餐厅注册并提供必要的餐厅信息。菜单管理：允许餐厅管理菜单，包括添加、修改和删除菜品信息以及设置价格和库存等。订单管理：提供对新订单的接收、订单状态的更新和订单历史记录的查看等功能。\\3. 用户浏览与点餐：餐厅浏览：允许用户浏览注册在平台上的餐厅列表。菜单浏览：允许用户查看餐厅的菜单、价格和菜品描述等详细信息。菜品搜索：提供菜品搜索功能，使用户可以根据关键词快速找到所需菜品。加入购物车：允许用户将菜品添加到购物车中，选择数量和特殊要求。下单与支付：允许用户下单并选择支付方式，包括在线支付或货到付款等。\\4. 订单处理与配送：订单处理：当用户下单后，餐厅接收订单并准备食物。配送管理：将订单分配给骑手，包括骑手的调度和路线规划等。订单状态跟踪：允许用户跟踪订单的状态，包括餐厅确认、食物制作、配送中和已送达等。\\5. 用户评价与反馈：订单评价：允许用户对已完成的订单进行评价和打分。反馈与投诉：提供用户反馈和投诉的渠道，以便改进服务质量和解决问题。\\6. 平台管理与统计：餐厅审核与管理：管理员对餐厅的注册信息进行审核和管理。数据统计与分析：提供对订单、用户活动和销售数据的统计和分析功能，以便做出决策和优化服务。2.2 系统的数据流图根据用户的需求和用户的实际业务流程分析，本系统的顶层数据流图如图1所示。图1 系统顶层数据流图2.3系统的性能需求1、精度订单准确性: 系统应准确处理订单，确保所需的外卖菜品和数量与用户提交的订单一致。交付准确性: 系统应确保外卖骑手将订单准确交付给正确的用户地址。2、时间特性要求订购提前时间: 用户下单时，系统应明确指示需要提前多少时间来处理和准备订单。系统更新时间: 系统的更新处理应在合理的时间范围内完成，以确保订单和菜单等数据的实时性。数据查询时间: 系统的数据查询操作应在可接受的时间范围内返回结果，以提供快速的用户体验。数据统计时间: 系统的数据统计操作应在可接受的时间范围内完成，以便进行报表生成和业务决策。3、灵活性订购修改和撤销: 在订单未处理审核之前，用户应可以灵活地修改或撤销已提交的订单。一旦订单通过审核，修改和撤销操作可能会受到限制。操作方式: 系统应支持鼠标和键盘的灵活切换，以满足用户的不同操作习惯和偏好。系统接口: 系统应提供与其他相关系统的接口，以便与支付、配送等外部服务进行集成。4、故障处理要求在输入不符合定义格式的数据时，软件应出现提示信息，而不是死机或是删除已经输入的信息，然后再弹出输入界面重新开始。第3章 系统设计根据第2章的需求分析的结果需求进行系统设计，对系统进行模块的划分及确定模块间的关系，设计出系统的功能结构图，然后对主要模块进行详细设计。3.1 系统功能划分为了加强系统的安全性，增加了系统用户身份验证功能，因此高校教材购销管理系统的功能可以划分为4大模块：1）用户管理模块：负责处理用户身份验证和管理，包括用户登录、注册、修改个人信息、退出等功能。2）菜单管理模块：用于管理外卖菜单，包括浏览菜单、搜索菜品、查看详细信息、添加菜品到购物车等功能。3）购物车管理模块：处理用户的购物车操作，包括添加菜品、修改菜品数量、移除菜品、计算订单总价等功能。4）订单管理模块：负责处理用户的订单操作，包括生成订单、选择送货地址、选择支付方式、查看订单状态等功能。5）配送管理模块：处理外卖订单的配送过程，包括接收订单、分配骑手、更新订单状态、确认送达等功能。6）评价管理模块：用于用户对外卖服务进行评价和反馈，包括评价订单、查看评价信息、提供客户服务等功能。本系统使用层次图来描述该系统软的层次结构，矩形框表示一个模块，矩形框之间的直线表示模块之间的调用关系。系统的功能结构图如图2所示，且对每个模块分别进行了编号。图2 系统功能结构图3.2 主要模块详细设计1.1 验证用户模块：功能描述：该模块用于验证用户的身份和权限，确保只有合法用户可以访问系统。输入用户信息，包括用户名和密码。从用户数据库中查找该用户信息。如果用户信息存在，则验证用户身份和权限。如果验证成功，输出用户验证成功的提示信息，并允许用户进入系统。如果验证失败，输出用户验证失败的提示信息，并阻止用户进入系统。1.2 修改用户密码模块：功能描述：该模块用于允许用户修改其登录密码。输入用户ID、旧密码和新密码。从用户数据库中查找该用户信息。如果用户信息存在，比对输入的旧密码与数据库中存储的密码。如果旧密码匹配，更新数据库中的密码为新密码。输出密码修改成功的提示信息。如果旧密码不匹配，输出密码修改失败的提示信息。2.1 输入外卖订单模块：功能描述：该模块用于用户下单并生成外卖订单。输入用户ID、选购的菜品信息、送货地址和支付方式。创建一个新的订单，并生成唯一的订单ID。将用户ID、菜品信息、送货地址、支付方式等存储到订单数据库中。输出订单提交成功的提示信息，包括订单ID。2.2 处理外卖订单模块：功能描述：该模块用于处理外卖订单的配送流程。输入订单ID。从订单数据库中查找该订单信息。如果订单信息存在，处理订单的配送流程，包括接收订单、分配骑手、更新订单状态等。输出订单处理成功的提示信息，包括骑手信息和预计送达时间。2.3 查询外卖订单模块：功能描述：该模块用于用户查询其外卖订单的详细信息。输入用户ID。从订单数据库中根据用户ID查询相应的订单信息。如果订单信息存在，输出订单的详细信息，包括菜品、配送状态、送达时间等。如果订单信息不存在，输出订单不存在的提示信息。3.2 骑手用户聊天信息模块：功能描述：该模块用于骑手和用户之间的聊天记录查询。输入骑手ID和用户ID。从聊天数据库中根据骑手ID和用户ID查询聊天记录。如果聊天记录存在，输出聊天记录的详细信息，包括发送时间、发送方和接收方的内容。如果聊天记录不存在，输出聊天记录不存在的提示信息。4.1 评价信息模块：功能描述：该模块用于查询外卖订单的评价信息。输入订单ID。从评价数据库中根据订单ID查询评价信息。如果评价信息存在，输出评价内容和评分。如果评价信息不存在，输出评价信息不存在的提示信息。4.3 骑手配送信息模块：功能描述：该模块用于查询骑手的配送信息和统计配送数据。输入骑手ID。从配送数据库中根据骑手ID查询配送信息。如果配送信息存在，输出配送信息的统计数据，包括订单数量、送达时间等。如果配送信息不存在，输出配送信息不存在的提示信息。第5章 系统测试软件测试的目的是为了发现软件设计和实现过程中的疏忽所造成的错误。5.1 测试需求本系统需要对以下的系统功能进行测试：1、系统操作登录注册。用户登录时进行相关测试是否可以正常的登录。2、主要模块的测试a. 输入外卖订单模块：测试用户输入外卖订单的功能。b. 处理外卖订单模块：测试系统处理外卖订单的功能。c. 查询外卖订单模块：测试用户查询外卖订单的功能。d. 骑手用户聊天信息模块：测试骑手和用户之间的聊天功能。e. 评价信息模块：测试用户对外卖订单进行评价的功能。f. 骑手配送信息模块：测试骑手配送信息的显示功能。5.2 测试方法​\t\t由于本次测试的依据是需求，所以才用黑盒测试方法。用黑盒测试法注重于测试软件的功能需求，主要试图发现下列几类错误：功能不对或遗漏；初始化和终止错误；界面错误；数据结构或外部数据源访问错误。功能测试主要采用等价类划分的策略，手动模拟正常、异常输入。5.3 测试过程通过分析，该系统的测试过程如表1所示。表1 系统的测试过程            测试功能模块      合理的输入数据      不合理输入数据      测试结果                  用户登录模块测试      使用有效的用户名和密码进行登录      使用无效的用户名和密码进行登录      合法用户可成功登录，非法用户无法登录              修改用户密码模块测试      输入有效的用户ID、旧密码和新密码      输入无效的用户ID、旧密码和新密码      密码修改成功或失败的提示信息              输入外卖订单模块测试      输入有效的用户ID、菜品信息、送货地址和支付方式      输入无效的订单信息      订单成功提交或错误提示信息              处理外卖订单模块测试      输入有效的订单ID      输入无效的订单ID      订单处理成功或错误提示信息              查询外卖订单模块测试      输入有效的用户ID      输入无效的用户ID      订单信息显示或错误提示信息              骑手用户聊天信息模块测试      输入有效的骑手ID和用户ID      输入无效的骑手ID和用户ID      聊天记录显示或错误提示信息              评价信息模块测试      输入有效的订单ID      输入无效的订单ID      评价内容显示或错误提示信息              骑手配送信息模块测试      输入有效的骑手ID      输入无效的骑手ID      配送信息显示或错误提示信息      5.4 测试结论​\t\t以上所有的模块测试过程，系统能在用户输入出错时，给出正确的响应，并不影响数据的安全与完整性。本系统主要模块通过了测试。第6章 总结与体会​\t\t在进行 Vue 外卖项目的实践过程中，我们深入理解了软件工程的重要性以及其在项目开发中的应用。通过遵循软件工程的原则和方法，我们成功地完成了项目的开发，并对其进行了测试。在项目的实践中，我们明确了项目需求，设计了合理的软件架构，并采用了适当的开发工具和技术。我们遵循了软件开发的生命周期，包括需求分析、设计、编码、测试和部署等阶段，并进行了合理的时间和资源规划。在测试阶段，我们采用了黑盒测试的方法，着重测试了功能需求，并通过手动模拟正常和异常输入来发现潜在的错误。通过测试过程，我们发现并修复了一些功能不符合或遗漏的问题，保证了系统的功能完整性和安全性。​\t\t通过本次项目实践，我们对软件工程的重要性有了更深刻的认识。软件工程提供了一种系统化的方法来规划、设计、开发和维护软件项目，使项目开发更加有序、高效，并能够及时发现和解决问题。同时，合理的测试方法和过程对于确保软件质量和稳定性也至关重要。​\t\t需求分析的重要性：在项目开发之前，充分理解和明确需求是非常关键的。只有清晰地定义需求，才能更好地规划开发过程，并确保最终的软件产品符合用户的期望。​\t\t软件架构的设计与优化：良好的软件架构可以提高项目的可维护性、扩展性和性能。在项目中，我们经过仔细的设计和优化，选择了合适的架构模式和技术栈，使得整个项目结构清晰、模块化，并具备良好的用户体验。测试的重要性：测试是保证软件质量的重要手段。通过测试过程，我们能够及时发现和解决潜在的问题，提高软件的可靠性和稳定性。在今后的项目开发中，我们将继续注重测试环节，并采用更全面和自动化的测试方法。​\t\t团队协作与沟通：项目开发是一个团队合作的过程，有效的团队协作和沟通对于项目的成功至关重要。在本次实践中，我们通过有效的协作和沟通，分工明确、配合"
  },
  
  {
    "title": "音乐播放器实践报告",
    "url": "/posts/%E9%9F%B3%E4%B9%90%E6%92%AD%E6%94%BE%E5%99%A8%E5%AE%9E%E8%B7%B5%E6%8A%A5%E5%91%8A/",
    "categories": "Vue实训",
    "tags": "课程, 报告",
    "date": "2023-06-09 09:43:00 +0800",
    





    
    "snippet": "一、项目需求分析音乐的魅力在生活中是极其大的,不同的国家、不同语言的人,可以从音乐中体会到相同的情感,可以加强人与人之间的联系, 我们也可以从音乐中了解他国, 因为音乐是人类共同的食粮, 它也可以让身体放轻松, 解压力, 避免因自律神经紧张失调而导致慢性疾病的产生。可以,解忧郁苦闷的心情,甚至可以做到某些程度的心灵治疗。因此为使人们能够随时听到音乐, 音乐播放器则应时被创造出来了, 它为用户...",
    "content": "一、项目需求分析音乐的魅力在生活中是极其大的,不同的国家、不同语言的人,可以从音乐中体会到相同的情感,可以加强人与人之间的联系, 我们也可以从音乐中了解他国, 因为音乐是人类共同的食粮, 它也可以让身体放轻松, 解压力, 避免因自律神经紧张失调而导致慢性疾病的产生。可以,解忧郁苦闷的心情,甚至可以做到某些程度的心灵治疗。因此为使人们能够随时听到音乐, 音乐播放器则应时被创造出来了, 它为用户提供了便利, 使得人们可以通过WEB网页在任何时候欣赏到音乐, 为了使音乐播放器出现, 必须依据手机为载体通过设计出一个基于WEB系统的音乐播放器。1.歌曲搜索：允许用户通过关键词搜索歌曲，并显示搜索结果列表。2.歌曲播放：提供歌曲的播放、暂停、上一曲、下一曲等基本播放控制功能。3.歌单管理：允许用户创建、编辑和删除歌单，并将收藏的歌曲添加到歌单中。4.排行榜：显示热门歌曲排行榜，包括全球榜、华语榜等。5.评论功能：可以让用户根据听歌后的感受撰写评论，并且可以分享二、项目总体设计1.歌曲搜索功能：提供用户界面的搜索框，允许用户输入关键词进行歌曲搜索。调用第三方音乐接口，如网易云音乐API，发送请求并获取搜索结果。将搜索结果以列表的形式展示给用户，显示歌曲的基本信息，如歌曲名、歌手、专辑等。2.第三方音乐接口调用：使用合适的第三方音乐接口，如网易云音乐API，通过发送HTTP请求获取音乐相关的数据，如歌曲信息、歌曲链接等。处理接口返回的数据，提取所需的信息，并进行适当的处理和展示。3.歌曲列表：在用户界面上展示歌曲列表，包括搜索结果列表、歌单中的歌曲列表等。显示每首歌曲的基本信息，如歌曲名、歌手、专辑封面等。提供点击歌曲列表中的歌曲，触发播放功能。4.播放功能：允许用户点击歌曲列表中的歌曲，实现歌曲的播放功能。调用第三方音乐接口获取歌曲的音频链接。使用合适的音频播放器组件，如HTML5音频标签或其他相关技术，进行歌曲的播放、暂停、上一曲、下一曲等基本控制操作。显示当前播放的歌曲信息，如歌曲名、歌手、专辑封面等。5.胶盘的旋转：在播放功能中，通过合适的CSS样式或JavaScript动画效果，实现胶盘的旋转效果。根据当前歌曲的播放状态，控制胶盘的旋转速度和方向。歌曲图片的替换旋转：根据当前播放的歌曲，从第三方音乐接口获取相应的歌曲图片。根据播放状态和胶盘的旋转效果，控制歌曲图片的替换和旋转效果。6.评论的获取：调用第三方音乐接口，获取当前歌曲的评论信息。将评论信息展示给用户，包括评论的内容、评论者的信息等。三、程序模块设计与实现1. 功能需求：(1)歌曲搜索模块：- 提供搜索框供用户输入关键词搜索歌曲。- 调用网易云音乐的API或其他相关接口进行歌曲搜索。- 将搜索结果以列表的形式展示给用户，显示歌曲的基本信息，如歌曲名、歌手、专辑等。(2)歌曲播放模块：- 提供歌曲的播放、暂停、上一曲、下一曲等基本控制按钮。- 加载选定歌曲的音频资源，并通过HTML5音频标签或其他相关技术进行播放。- 显示当前播放的歌曲信息，如歌曲名、歌手、专辑封面等。(3)歌单管理模块：- 允许用户创建、编辑和删除歌单。- 提供添加、删除歌曲到歌单的功能。- 显示用户已创建的歌单列表，并提供对歌单的编辑和删除操作。(4)排行榜模块：- 显示热门歌曲的排行榜，包括全球榜、华语榜等。- 点击排行榜中的歌曲可进行播放。- 提供对排行榜的更新和刷新功能。(5)评论功能模块：- 允许用户根据听歌后的感受撰写评论。- 提供评论提交和显示功能。- 可以将评论分享给其他用户或社交媒体。2. 用户界面设计：根据功能需求，设计用户界面可以包括以下页面和组件：(1)主页：- 包含搜索框和搜索结果列表，用于歌曲搜索。- 显示当前播放的歌曲信息和基本控制按钮。(2)歌单页面：- 显示用户创建的歌单列表，包括歌单名称和封面。- 点击进入具体歌单页面，显示歌单中的歌曲列表和编辑、删除操作按钮。(3)排行榜页面：- 显示热门歌曲排行榜，包括全球榜、华语榜等。- 点击排行榜中的歌曲进入播放页面。(4)播放页面：- 显示当前播放的歌曲信息，如歌曲名、歌手、专辑封面等。- 提供播放、暂停、上一曲、下一曲等基本控制按钮。- 包含评论区域，用户可以撰写评论并提交。3．Vue组件（1）双向绑定Vue中可以使用v-model指令实现双向绑定，将表单元素的值与Vue实例中的数据进行关联，实现数据的双向同步。（2）vue指令Vue提供了多种指令，用于操作DOM元素和Vue实例之间的交互。常用的指令包括v-bind、v-if、v-show、v-for等。这些指令可以通过在HTML元素上添加相应的指令进行使用。（3）计算属性、侦听器Vue中的计算属性和侦听器用于处理响应式数据的变化。计算属性是基于Vue实例的响应式数据进行计算，并返回计算结果。计算属性具有缓存机制，只有依赖的响应式数据发生改变时，才会重新计算。侦听器（watcher）用于监听指定的响应式数据，并在数据变化时执行相应的操作。通过在Vue实例中定义watch选项，可以设置侦听器。（4）vue事件绑定及行为阻止Vue可以通过v-on指令实现事件绑定，将DOM事件与Vue实例中的方法进行关联。可以通过事件修饰符（如.prevent、.stop等）来控制事件的行为。.prevent修饰符用于阻止事件的默认行为。.stop修饰符用于阻止事件冒泡。（5）axios异步通信Axios是一个基于Promise的HTTP客户端，用于进行异步通信。在Vue项目中，可以使用Axios发送HTTP请求，与后端进行数据交互。通过Axios发送GET、POST等HTTP请求，并处理返回的数据。可以在Vue组件的生命周期钩子函数中使用Axios进行数据获取和更新。以上是Vue组件中常用的功能和技术点，它们可以在Vue的组件中灵活应用（6）promise的作用Promise是一种用于处理异步操作的对象，它可以将异步操作的结果以回调函数的方式进行处理，使得异步代码的编写更加简洁和可读性更高。Promise的主要作用包括：处理异步操作：Promise可以处理异步操作，如异步请求、文件读取、定时器等。解决回调地狱问题：Promise通过链式调用的方式，可以避免回调函数嵌套过深的问题，提高代码的可读性和维护性。提供异步操作的状态和结果：Promise有三种状态：pending（进行中）、fulfilled（已成功）和rejected（已失败），可以通过then方法获取异步操作的结果。支持异常处理：Promise可以通过catch方法捕获异步操作中的错误，并进行相应的处理。（7）vue3中ES6的导入在Vue 3中，可以使用ES6的导入语法来引入其他模块、组件或函数。导入语法示例：// 导入单个模块import { module } from ‘./module’;// 导入默认导出的模块import module from ‘./module’;// 导入所有导出的内容import * as module from ‘./module’;（8）vue3中ajax请求发送位置在Vue 3中，可以在组件的生命周期钩子函数或方法中发送AJAX请求。常见的位置包括：在created钩子函数中发送初始化数据请求。在事件处理函数中发送请求，如按钮点击事件等。在方法中根据需要发送请求，比如在点击某个元素时触发的方法中发送请求。（9）get请求的参数拼写在GET请求中，参数可以通过查询字符串的形式拼接在URL的后面。通常的拼写方式是将参数名和值用等号连接，多个参数之间使用&amp;符号进行连接。示例：https://example.com/api?param1=value1&amp;param2=value2（10）mvc和mvvm设计模式MVC（Model-View-Controller）是一种软件设计模式，用于分离应用程序的关注点，包括数据（Model）、用户界面（View）和业务逻辑（Controller）。MVVM（Model-View-ViewModel）是一种衍生自MVC的设计模式，它将数据的展示和用户交互分离开来。在MVVM中，ViewModel充当了Controller的角色，负责处理用户交互和业务逻辑，并与View和Model进行双向数据绑定。（11）v-if和v-show的区别编译时机：v-if：在条件为真时，元素及其内容会被编译和渲染到DOM中。在条件为假时，元素及其内容不会被编译和渲染，直接从DOM中移除。v-show：无论条件是真还是假，元素都会被编译和渲染到DOM中，只是通过CSS的display属性来控制元素的显示或隐藏。初始渲染开销：v-if：在初始渲染时，如果条件为假，元素不会被渲染到DOM中，从而减少了初始渲染的开销。v-show：无论条件是真还是假，元素都会被渲染到DOM中，因此初始渲染的开销较大。切换开销：v-if：在条件发生变化时，如果条件从假变为真，元素会被编译和渲染到DOM中；如果条件从真变为假，元素会从DOM中移除。v-show：在条件发生变化时，如果条件从假变为真，元素通过修改CSS的display属性来显示；如果条件从真变为假，元素通过修改CSS的display属性来隐藏。因此，切换时只是修改了CSS属性，开销较小。频繁切换：v-if：适合在条件不经常发生变化的情况下使用，因为切换时有较大的开销。v-show：适合在条件需要频繁切换的情况下使用，因为切换时开销较小。2．项目实现（1）歌曲搜索功能searchSong() { // console.log(66666); // 获取输入的内容,判断是否为空// console.log(this.songName);if (!this.songName) {return;  }  // 发送请求获取歌曲  let that = this;   // 为给定 ID 的 user 创建请求  axios.get('https://autumnfish.cn/search?keywords=' + this.songName)   .then(res =&gt; {    // console.log(res);    // 获取当前请求状态和返回的歌曲    let { status, data } = res;    if (status == 200) {      // console.log(data);     if (data.result.songs) {      that.songsList = data.result.songs;      // console.log(that.songsList);     }    }   }).catch(err =&gt; {     console.log(err);   }); }（2）第三方音乐接口调用axios.get('https://autumnfish.cn/search?keywords=' + this.songName)   .then(res =&gt; {    let { status, data } = res;    if (status == 200) {      if (data.result.songs) {      that.songsList = data.result.songs;     }    }   }).catch(err =&gt; {    console.log(err);（3）歌曲列表axios.get('https://autumnfish.cn/search?keywords=' + this.songName) .then(res =&gt; {  let { status, data } = res;  if (status == 200) {   if (data.result.songs) {    that.songsList = data.result.songs;    }  } }).catch(err =&gt; {  console.log(err);（4）播放功能playerSong() { let id = window.event.target.dataset.id; axios.get('https://autumnfish.cn/song/url?id=' + id).then(res =&gt; {  this.musicUrl = res.data.data[0].url;  this.showPlaying(); }); axios.get('https://autumnfish.cn/song/detail?ids=' + id).then(res =&gt; {  this.playImg = res.data.songs[0].al   .picUrl }); this.getCommentList(id);},（5）胶盘的旋转.autoRotate {   animation-name: Rotate;   animation-iteration-count: infinite;   animation-play-state: paused;   animation-timing-function: linear;   animation-duration: 5s;  }（6）歌曲图片的替换旋转showPlaying(){  this.$refs.cover.classList.add('playing')  this.$refs.disc.classList.add('playing')  this.$refs.playBar.classList.add('playing') }（7）评论的获取getCommentList(id){ axios.get('https://autumnfish.cn/comment/hot?id=' + id + '&amp;type=0').then(res =&gt; {  this.hotComment = res.data.hotComments;  console.log(this.hotComment); })}运行结果四、总结及心得体会在完成基于Vue的音乐播放器前端Web实验后，我对Vue框架和前端开发有了更深入的理解，并积累了一些宝贵的经验和体会。首先，通过这个实验，我学会了如何使用Vue框架构建一个具有实际功能的Web应用。Vue提供了丰富的工具和功能，如组件化开发、响应式数据绑定、指令等，使得开发过程更加高效和灵活。我发现Vue的双向数据绑定能够大大简化数据的处理和更新，使得用户界面与数据之间的同步变得更加便捷。其次，通过调用第三方音乐接口实现音乐的搜索、播放和获取歌曲信息，我了解到了如何与外部API进行交互和数据获取。这拓展了我的视野，让我意识到前端开发不仅仅局限于界面设计和交互，还可以通过调用API获取数据，并将其展示给用户，为用户提供更丰富的功能和体验。在开发过程中，我也遇到了一些挑战和问题。比如，处理异步操作时需要注意回调函数的使用，合理地处理数据加载的过程，以避免用户体验的延迟。此外，对于音乐播放器来说，控制音频的播放、暂停、切换等功能需要细致地处理，以确保用户能够良好地使用和操作。通过这个实验，我对前端开发的整个流程有了更清晰的认识，包括需求分析、设计界面、编写代码、调试和优化等。同时，也加深了对团队协作的理解，因为在开发中可能需要与后端开发人员进行协作，确保前后端的数据交互和功能实现的一致性。总的来说，这个实验让我对Vue框架和前端开发有了更深入的了解和实践，同时也培养了我的问题解决能力和团队合作能力。通过不断学习和实践，我相信我能够在前端开发领域取得更多的进步。"
  },
  
  {
    "title": "Vue 第 4 天 - Vue 监听器 自定义指令 模块化",
    "url": "/posts/vue-%E7%AC%AC-4-%E5%A4%A9-vue-%E7%9B%91%E5%90%AC%E5%99%A8-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4-%E6%A8%A1%E5%9D%97%E5%8C%96/",
    "categories": "Vue实训",
    "tags": "课程",
    "date": "2023-06-08 22:26:00 +0800",
    





    
    "snippet": "Vue 第 4 天 - Vue 监听器 自定义指令 模块化视频链接：视频链接代码链接：代码链接01 - 监听器 watch  使用 watch 来侦听 data 中数据的变化，watch 中的属性一定是 data 中已经存在的数据。  watch 本身是个对象,里面的方法名要和data中的属性名一致.  使用场景：数据变化时执行异步或开销比较大的操作。    案例效果：    参考代码：  ...",
    "content": "Vue 第 4 天 - Vue 监听器 自定义指令 模块化视频链接：视频链接代码链接：代码链接01 - 监听器 watch  使用 watch 来侦听 data 中数据的变化，watch 中的属性一定是 data 中已经存在的数据。  watch 本身是个对象,里面的方法名要和data中的属性名一致.  使用场景：数据变化时执行异步或开销比较大的操作。    案例效果：    参考代码：  &lt;body&gt;  &lt;div id=\"app\"&gt;    &lt;p&gt;      &lt;input type=\"text\" v-model='firstName' placeholder=\"姓\" /&gt;    &lt;/p&gt;    &lt;p&gt;      &lt;input type=\"text\" v-model='lastName' placeholder=\"名\" /&gt;    &lt;/p&gt;    &lt;p&gt;      &lt;input type=\"text\" v-model='fullName' placeholder=\"全名\" /&gt;    &lt;/p&gt;  &lt;/div&gt;  &lt;script type=\"module\"&gt;    import { createApp } from './vue.js'    createApp({      data() {        return {          firstName: '',          lastName: '',          fullName: ''        }      },      watch: {        firstName(val) {          this.fullName = val + this.lastName        },        lastName(val) {          this.fullName = this.firstName + val        }      }    }).mount('#app');  &lt;/script&gt;&lt;/body&gt;    注意点：      声明监听器，使用的关键词是watch    每个监听器的方法，可以接受 2 个参数，第一个参数是新的值，第二个参数是之前的值  02- MVC 开发模式  开发模式，就是一个开发项目的方式或者标准，比较有代表的两种开发模式：      MVC    MVVM    MVC 模式介绍  MVC 全名是 Model View Controller，是模型 (model) －视图 (view) －控制器 (controller) 的缩写，一种软件设计典范，用一种业务逻辑（C）、数据（M）、界面显示（V）分离的方法组织代码，将业务逻辑聚集到一个部件里面，在改进和个性化定制界面及用户交互的同时，不需要重新编写业务逻辑。              用户可以向 View 发送指令（DOM 事件），再由 View 直接要求 Model 改变状态。              用户也可以直接向 Controller 发送指令（改变 URL 触发 hashChange 事件），再由 Controller 发送给 View。              Controller 非常薄，只起到路由的作用，而 View 非常厚，业务逻辑都部署在 View。        优点        \t耦合性低，重用性高，部署快，可维护性高，有利于软件工程化管理              缺点        \t由于模型 model 和视图 view 要严格的分离，给前端程序带来了很大的困难，每次操作需要彻底的测试            03- MVVM 开发模式  MVVM 模式            M：（model）普通的 javascript 数据对象              V：（view）前端展示页面              VM：（ViewModel）用于双向绑定数据与页面，对于我们的课程来说，就是 vue 的实例              MVVM 模式采用双向绑定（data-binding）：View的变动，自动反映在 ViewModel，反之亦然。这种模式下，页面输入改变数据，数据改变影响页面数据展示与渲染              vue 使用 MVVM 响应式编程模型，避免直接操作 DOM , 降低 DOM 操作的复杂性。                            优点      低耦合，视图（View）可以独立于 Model 变化和修改，一个 ViewModel 可以绑定到不同的 View 上，当 View变化的时候 Model 可以不变，当 Model 变化的时候 View 也可以不变。    可重用性，你可以把一些视图逻辑放在一个 ViewModel 里面，让很多 view 重用这段视图逻辑。    可测试，界面素来是比较难于测试的，而现在测试可以针对 ViewModel 来写。  04-MVC与MVVM原理对比图解对比传统的前端是将数据手动渲染到页面上，需要用户操作DOM元素。而MVVM模式不需要用户手动操作DOM元素，而是将数据绑定到viewModel层上，然后数据会自动被渲染到页面上。View视图层一发生变化，它就会通知viewModel层开始更新数据，viewModel就是MVVM模式中的桥梁。MVVM的重要之处在于两个，一个是Data Bindings数据绑定，另一个是Dom Listeners事件监听。05  - Demo 云播放器  文档地址  实现步骤      输入内容，点击回车，查询数据，渲染页面                        v-model :music                            @keyup.enter:searchMusic        axios.get(‘https://autumnfish.cn/search?keywords=深圳’)        .then() musicList        v-for              双击歌曲列表，播放双击的歌曲                        dblclick: playMusic（歌曲的id）                            axios接口调用 https://autumnfish.cn/song/url?id=33894312        .then()        放歌要设置src，歌曲的url地址                       - src属性                                            v-bind:src=musicUrl                          歌曲封面获取:https://autumnfish.cn/song/detail?ids=347234        获取评论：https://autumnfish.cn/comment/hot?id=186015&amp;type=0              注意点            不同的接口返回的数据时不同的，这个例子换了一个接口              数据回来之后如果比较复杂，依次逐级的去找，不要害怕              工作中，基本上所有的数据都是由接口提供，不同的接口功能不同，前端开发中，天天调不同的接口        audio 通过设置src可以放歌，vue中不要认为操纵dom元素，要通过数据去间接操纵              v-bind:src=\"musicUrl\"              版权问题                        企业中，如果要做播放器，一定要考虑版权问题                            学习节点，个人玩耍，只要不商用，不盈利，不会侵权            "
  },
  
  {
    "title": "Vue 第 3 天 - 计算属性、网络请求、生命周期及动画",
    "url": "/posts/vue-%E7%AC%AC-3-%E5%A4%A9-%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7-%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%8F%8A%E5%8A%A8%E7%94%BB/",
    "categories": "Vue实训",
    "tags": "课程",
    "date": "2023-06-07 22:46:00 +0800",
    





    
    "snippet": "Vue 第 3 天 - 计算属性、网络请求、生命周期及动画视频链接：视频链接代码链接：代码链接01 - 计算属性 computed  手册 https://cn.vuejs.org/guide/essentials/computed.html  任何复杂逻辑，你都应当使用计算属性，计算属性是 Vue 的一个非常非常利好的特性。模板中的表达式虽然方便，但也只能用来做简单的操作。如果在模板中写太...",
    "content": "Vue 第 3 天 - 计算属性、网络请求、生命周期及动画视频链接：视频链接代码链接：代码链接01 - 计算属性 computed  手册 https://cn.vuejs.org/guide/essentials/computed.html  任何复杂逻辑，你都应当使用计算属性，计算属性是 Vue 的一个非常非常利好的特性。模板中的表达式虽然方便，但也只能用来做简单的操作。如果在模板中写太多逻辑，会让模板变得臃肿，难以维护      computed 和data 平级。计算属性作为 computed 里面的一个方法，必须 return。    使用的时候和 data 里面的属性一样。    计算属性所依赖的属性(data中数据)有变化的时候，计算属性会重新计算。  基本使用,逻辑都写在行内,臃肿!&lt;body&gt;  &lt;div id=\"app\"&gt;    &lt;span&gt;&lt;/span&gt;  &lt;/div&gt;  &lt;script type=\"module\"&gt;    import { createApp } from './vue.js';    createApp({      data() {        return {          author: {            name: '路遥',            books: [              '平凡的世界',              '人生',            ]          }        }      }    }).mount('#app')  &lt;/script&gt;&lt;/body&gt;将内容都写在computed中this.publishedBooksMessage 依赖于 this.author.books，所以当 this.author.books 改变时，任何依赖于 this.publishedBooksMessage 的绑定都将同时更新。&lt;body&gt;  &lt;div id=\"app\"&gt;    &lt;span&gt;&lt;/span&gt;  &lt;/div&gt;  &lt;script type=\"module\"&gt;    import { createApp } from './vue.js';    createApp({      data() {        return {          author: {            name: '路遥',            books: [              '平凡的世界',              '人生',            ]          }        }      },      computed: {        // 方法名就是标签内引用的名字        publishedBooksMessage() {          return this.author.books.length &gt; 0 ? this.author.name : '啥也没有'        }      }    }).mount('#app')  &lt;/script&gt;&lt;/body&gt;结合日期插件的实现moment为日期插件,专门用于格式化时间  &lt;body&gt;  &lt;div id=\"app\"&gt;    &lt;h2&gt;成为京东会员的日期：&lt;/h2&gt;    &lt;input type=\"text\" v-model=\"date\" /&gt;    &lt;h2&gt;格式化后的日期 &lt;/h2&gt;    &lt;h2&gt;您已经京东会员天&lt;/h2&gt;  &lt;/div&gt;  &lt;script src=\"./moment.js\"&gt;&lt;/script&gt;  &lt;script type=\"module\"&gt;    import { createApp } from './vue.js';    createApp({      data() {        return {          date: '2019-8-8 8:05'        }      },      computed: {        // 方法名就是标签内引用的名字        formatDate() {          return moment(this.date).format('YYYY-MM-DD HH:mm:ss a')        },        vipDays() {          console.log('重新计算')          return Math.ceil((Date.now() - new Date(this.date)) / (24 * 60 * 60 * 1000))        }      }    }).mount('#app')  &lt;/script&gt;&lt;/body&gt;  02 - Demo 品牌管理  需求分析      基础 对象数组 v-for 渲染到页面上    表单输入 v-model    @keyup.enter 绑定事件    通过计算属性计算需要显示的数据    点击 新增品牌 @click 展示弹窗    输入内容， push 进数组    注意事项      品牌列表是一个过滤的数组，过滤条件是品牌名称包含搜索的关键词。    计算属性可以用在 for 里面。    字符的非空判断建议用if(!str)  等价于 if(str=='')。    Array 的 filter 返回一个符合条件的所有元素的新数组。    let arr =[4,6,67,78,234,345,33,543,53,34,34,534,53,534,5,345]let filterArr = arr.filter(function(item){  console.log(item)  return item&gt;50})console.log(arr,filterArr)    \t1. 展示列表        1. 品牌列表数组 brandList:[            {              name:'小米',              time:'2019-07-26 10:36:38 am'            },            {              name:'红米',              time:'2019-07-24 10:36:38 am'            }          ]        2. 列表展示: v-for tr    2.删除一项      1. 点击事件 @click:delBrand(index)      2. 数组移除元素 brandList.splice(从哪一个元素开始删除，删除多少个)    3.新增品牌      1.弹层的显示与隐藏        1. 弹层 v-show=\"isShow\"        1. 点击新增品牌，显示 @click isShow=true        2. 添加与取消 隐藏 @click isShow=false             2.新增品牌        1. v-model.trim:inputVal        2. @keyup.enter或者添加 addBrand        3. brandList.push({          name:'商品名称',          time: 当前的时间        })    4.搜索功能        1.v-model.trim:keywords        2.计算属性 filterBrandList           1. brandList根据keywords过滤后数组 item.name.includes(keywords  03- promise 异步处理在JavaScript的世界中，所有代码都是单线程执行的。由于这个“缺陷”，导致JavaScript的所有网络操作，浏览器事件，都必须是异步执行。异步执行可以用回调函数实现.div.onclick = function(){}Promise使ES6中引入的一个异步编程解决方案，与传统的ES5方法相比它的结构更合理，功能更强大.特点Promise对象代表一个异步操作，有三种状态：pending（进行中）、fulfilled（已成功）和rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态.语法:  var p = new Promise(function(resolve,reject){}) resolve 代表 决定(成功); reject 代表 失败使用    const p  = new Promise(function(resolve,reject){        setTimeout(function(){           // resolve('我是成功的')           reject('这是失败的');        },2000)    });.then(callback)的使用(成功时调用).catch(callback的用法(失败时调用)  p.then(function(data){\t\t\tconsole.log('resolved成功回调');\t\t\tconsole.log('成功回调接受的值：',data);\t\t}).catch(function(reason, data){\t\t    console.log('catch到rejected失败回调');\t\t     console.log('catch失败执行回调抛出失败原因：',reason);\t});\t效果和写在then的第二个参数里面一样。它将大于10的情况下的失败回调的原因输出注意:resolve和reject的两种状态resolve作用是，将Promise对象的状态从“未完成”变为“成功”（即从 pending 变为 resolved），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；reject作用是，将Promise对象的状态从“未完成”变为“失败”（即从 pending 变为 rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。结合函数我们用Promise的时候一般是包在一个函数中，在需要的时候去运行这个函数 let promiseFn =()=&gt;{\t console.log('点击方法被调用')\t let p = new Promise(function(resolve, reject){\t\t//做一些异步操作\t\tsetTimeout(function(){\t\t\t\tconsole.log('执行完成Promise');\t\t\t\tresolve('成功的时候调用');\t\t\t}, 2000);\t\t});        return p\t}promiseFn().then(function(data){     console.log(11111)}).catch(function(data){     console.log(2222)})静态方法的使04 - 网络请求原生 XMLHttpRequest      浏览器对 XMLHttpRequest 对象的支持度不足, 创建 XMLHttpRequest 对象时需要对 IE 做兼容，XMLHttpRequest 本质上来讲其实也是一个事件监听行为。        readyState                        0-4，0表示未初始化，4表示请求已完成                      status（HTTP响应状态码）                        200：OK，成功                            3XX【重定向系列的状态码】                      - 301：永久重定向                                            302：临时重定向            307：内部浏览器（缓存）重定向                          4XX【错误系列】                      - 400：bad request，错误请求                                            401：鉴权失败            403：禁止访问            404：找不到对应的资源            405：方法不被允许                          5XX【服务器错误，环境问题】                      - 500：服务器内部错误（代码、环境问题）                                            502：bad Getway，错误网关                                    案例：使用XHR请求全国高校数据接口        接口地址                        https://api.i-lynn.cn/college                            只循环展示list信息即可        接口可以直接被跨域请求              案例效果          参考代码：    &lt;body&gt;    &lt;div id=\"app\"&gt;        &lt;ul&gt;            &lt;li :key='index' v-for='(el,index) in list'&gt;：所&lt;/li&gt;        &lt;/ul&gt;    &lt;/div&gt;&lt;/body&gt;&lt;script src=\"./js/vue.js\"&gt;&lt;/script&gt;&lt;script&gt;    new Vue({        el: '#app',        data: {            list: []        },        mounted: function(){            // 1. 创建xhr对象            var xhr = new XMLHttpRequest()            const api = 'https://api.i-lynn.cn/college'            // 2. 绑定回调函数            xhr.onreadystatechange = () =&gt; {                // 3. 判断是否成功                if(xhr.readyState == 4 &amp;&amp; xhr.status == 200){                    this.list = JSON.parse(xhr.responseText).list                }            }            // 4. 打开请求            xhr.open('GET',api)            // xhr.open('POST',api)            // 设置请求头            // xhr.setRequestHeader(\"Content-Type\",\"application/x-www-form-urlencoded\");            // 5. 发送请求            xhr.send()            // xhr.send(\"username=111&amp;age=222\")        }    })&lt;/script&gt;    后期学习的PUT、DELETE等特殊的请求动词都会触发预检请求。05 - 网络请求 axios  官方文档      axios 是一个基于 promise 的 HTTP 库，可以用在浏览器和 node.js 中。axios 是 vue 作者推荐使用的网络请求库，它具有以下特性：                        支持浏览器和 node.js                            支持 promise        能够拦截请求和响应        自动转换 json 数据              axios 的浏览器支持。          axios 使用，先导包，再用包。    &lt;script src=\"https://unpkg.com/axios/dist/axios.min.js\"&gt;&lt;/script&gt;    // GET请求方式axios.get('/get_data?id=10010').then(ret =&gt; console.log(ret.data))axios.get('/get_data',{    params: {        id: 10010,        name: 'zhangsan',        age: 26    }}).then(ret =&gt; console.log(ret.data))//POST请求方式axios.post('/set_data', {  \tfirstName: 'zhang',  \tlastName: 'san'}).then(ret =&gt; { })axios({  \tmethod: 'post',  \turl: 'set_data',  \ttimeout: 1000,  \theaders: {'X-Custom-Header': 'foobar'},  \tdata: {    \tfirstName: 'zhang',    \tlastName: 'san'  \t}}).then(ret =&gt; { })        当然 axios 除了支持传统的GET和POST方式以外，常见的请求方式还支持：                        put：修改数据                            delete：删除数据              以上方的 axios 请求示例为例，axios 响应结果（res）的主要属性有：                        data：实际响应回来的数据（最常用）                            headers：响应头信息        status：响应状态码        statusText：响应状态信息              在使用 axios 发送请求之前它允许我们通过全局配置做一些设置，这样可以方便后续的请求操作，例如：                        axios.defaults.timeout = 3000【设置超时时间】                            axios.defaults.baseURL = 'http://localhost/app'【设置默认地址】        axios.defaults.headers['_token'] = '123123123'【设置请求头信息，通用头信息】                       - `_axios.defaults.headers.get['_token'] = '123123'`                                            axios.defaults.headers.post['_token'] = '123123'            axios.defaults.headers.common['_token'] = '123123'【通用头信息，common可以不写】                                注意事项                        axios发送post请求的时候，默认发送json格式数据                            如果需要发送post表单类型请求，则需要指定请求头              axios.post('college',{    username: 'zhangsan',    age: 22},{    headers: {        \"Content-Type\": \"application/x-www-form-urlencoded\"    }}).then(ret =&gt; this.list = ret.data.list)  06 - 网络请求 axios 拦截器  目的：在请求发出去之前/收到响应之后做一些操作      请求拦截器      示例代码：  axios.interceptors.request.use(function(config){    // 在请求发出去之前进行一些信息设置    return config;},function(err){    // 处理响应的错误信息});        响应拦截器      示例代码：  axios.interceptors.response.use(function(res){    // res为axios对象    return res;},function(err){    // 处理响应的错误信息});        axios 和 ajax 的区别                        ajax 使用的是 success、error 回调函数作为参数来使用的，如果回调层级过多，就会造成非常不好的代码体验，稍有不慎还有可能造成 回调地狱（无限调用）。                            axios 使用的是链式调用，什么是链式调用？正如我们上面的体验then、catch、finally是可以不断的被调用下去的。        axios 在链式调用的参数方法定义中，使用箭头函数确保能够绑定到当前 vue 实例上并能够顺利的调取 vue 声明的属性和方法。        如果说，我们不使用箭头函数，则需要在外围声明一个新的变量 let that = this，然后使用that来代表当前 vue 实例。        我们也可以配合使用 async await 来实现更加友好舒适的请求调用。            07-天气预报  需求分析  输入城市，显示搜索城市  获取输入的城市 v-model  点击回车 enter 键，响应 @keyup.enter  使用axios请求天气  使用 v-for 展示天气搜索结果  /*  1. 显示搜索城市    1. v-model:city    2.   2. 输入城市，回车，请求    1. @keyup.enter:queryWeather    2.axios  https://v0.yiketianqi.com/api?unescape=1&amp;version=v91&amp;appid=43656176&amp;appsecret=I42og6Lm&amp;ext=&amp;cityid=&amp;city=%E9%83%91%E5%B7%9E  3. 展示天气搜索结果    1. forecastList[]    2. v-for    3. v-if  */&lt;body&gt;  &lt;div id=\"app\"&gt;    &lt;h2&gt;天气查查&lt;/h2&gt;    &lt;input type=\"text\" v-model=\"city\" @keyup.enter=\"getWeather\"&gt;    &lt;input type=\"button\" @click=\"getWeather\" value=\"查询\"&gt;    &lt;p v-for=\"(v,k) in weatherData\"&gt; &lt;/p&gt;  &lt;/div&gt;  &lt;script src=\"https://unpkg.com/axios/dist/axios.min.js\"&gt;&lt;/script&gt;  &lt;script type=\"module\"&gt;    import { createApp } from './vue.js';    createApp({      data: function () {        return {          isShow: true,          city: '郑州',          weatherData: []        }      },      methods: {        getWeather() {          axios.get('https://v0.yiketianqi.com/api?unescape=1&amp;version=v91&amp;appid=43656176&amp;appsecret=I42og6Lm&amp;ext=&amp;cityid=&amp;city=' + this.city)            .then(({ data }) =&gt; {              // console.log(data);              this.weatherData = data.data;            })            .catch(function (error) {              console.log(error);            });        }      }    }).mount('#app')  &lt;/script&gt;&lt;/body&gt;08- Vue 生命周期钩子  文档  https://cn.vuejs.org/guide/essentials/lifecycle.html#lifecycle-diagram      声明周期的概念              每个 Vue 实例在被创建之前都要经过一系列的初始化过程。        例如需要设置数据监听、编译模板、挂载实例到 DOM，在数据变化时更新 DOM 等。        同时在这个过程中也会运行一些叫做生命周期钩子的函数，目的是给予用户在一些特定的场景下添加他们自己代码的机会。              Vue生命周期的主要阶段：        挂载（初始化相关属性）                        beforeCreate    &gt;    &gt;     - 注意点：在此时不能获取data中的数据，也就是说this.msg得到的是undefined                            created                             一般用于发送ajax请求                                      beforeMount        mounted【页面加载完毕的时候就是此时】                      - **注意点**：默认情况下，在组件的生命周期中只会触发一次                                            更新（元素或组件的变更操作）                        beforeUpdate                            updated                      - **注意点**：可以重复触发的                                          10 - 课后作业      灵活使用计算属性 computed    认真掌握网络请求 axios    理解 Vue 生命周期  "
  },
  
  {
    "title": "学生信息管理系统(Java Web版)",
    "url": "/posts/%E5%AD%A6%E7%94%9F%E4%BF%A1%E6%81%AF%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F-java-web%E7%89%88/",
    "categories": "项目",
    "tags": "Java",
    "date": "2023-06-07 21:59:00 +0800",
    





    
    "snippet": "  以下内容转载自 CSDN 博主的原创文章，遵循 CC 4.0 BY-SA 版权协议。  原文链接：链接在此学生信息管理系统(Java Web版)一、前置知识：（一）JDBC技术：JDBC是Java Database Connectivity（Java数据库连接）的缩写，编程人员可以通过这个API接口连接到数据库，并使用结构化查询语言（SQL）完成对数据库的查找和更新JDBC的目标是屏蔽不...",
    "content": "  以下内容转载自 CSDN 博主的原创文章，遵循 CC 4.0 BY-SA 版权协议。  原文链接：链接在此学生信息管理系统(Java Web版)一、前置知识：（一）JDBC技术：JDBC是Java Database Connectivity（Java数据库连接）的缩写，编程人员可以通过这个API接口连接到数据库，并使用结构化查询语言（SQL）完成对数据库的查找和更新JDBC的目标是屏蔽不同的数据库驱动程序之间的差别，为开发者提供一个标准的、纯Java的数据库程序设计接口，为在Java中访问不同类型的数据库提供技术支持在Java程序中，通过JDBC访问数据库的步骤如下：①装载并注册数据库的JDBC驱动程序；②建立与数据库的连接；③创建Statement对象；④调用SQL语句访问数据库；⑤处理ResultSet中的记录集；⑥关闭ResultSet、Statement和Connection对象。（二）MVC模式1.MVC组成MVC是 Model-View-Controller 的缩写，即模型-视图-控制器，是一种目前广泛流行的软件设计模式，MVC把一个应用的输入、处理、输出流程按照模型、视图、控制器的方式进行分离，从而将一个应用程序分成三个核心模块：模型、视图和控制器，它们各自完成不同的任务总的来说，模型是应用对象，视图时他在屏幕上的表示，控制器定义用户界面对用户输入的响应方式2.MVC模式两种开发模型：模型一：JSP+JavaBeans的结合模型二：JSP+JavaBeans+Servlet的结合二、该项目总体功能概述：本系统利用Java Web技术实现了学生信息管理系统，具有简单的学生信息管理功能。实现了一下功能模块：院系信息管理模块，学生信息管理模块，课程信息管理模块，成绩管理模块等。所用到的技术栈  mvc开发模式  jsp+Servlet  HTML5+CSS3+JavaScript等三、系统运行过程：四、详细设计与代码实现（一）建立数据库与相关表1.创建数据库：StudentInfoManagement2.创建相关表：class表：            字段      中文描述      数据类型                  Clno      班级编号      char(20)              Clname      班级名称      char(20)              Dno      所属院系      char(20)      Course表：            字段      中文描述      数据类型                  Cno      课程号      char(20)              Cname      课程名称      char(20)              Cteacher      老师      char(20)              Ccredit      学分      smallint      Department表:            字段      中文描述      数据类型                  Dno      所属院系      char(20)              Dname      系名      char(20)      SC表：            字段      中文描述      数据类型                  Sno      学号      char(20)              Cno      课程号      char(20)              Grade      成绩      smallint      Student表：            字段      中文描述      数据类型                  Sno      学号      char(20)              Sname      姓名      char(20)              Ssex      性别      char(20)              Sage      年龄      smallint              Clno      班级编号      char(20)      User表：            字段      中文描述      数据类型                  username      用户名      char(20)              password      密码      char(20)              level      权限级别      char(20)      （二）设计系统所需要的JavaBeanDBUtils.java类：该JavaBean将数据库连接操作和关闭操作封装起来，在以后的数据库操作中可以直接调用这个JavaBean的方法，该JavaBean应该包含的方法有：1.数据库的连接，获得一个连接对象的方法：Connection getConnection()2.当数据库操作完成后，关闭连接并释放资源的方法：closeConnection(Connection conn)实现代码：package utils;import java.sql.DriverManager;import java.sql.SQLException;import com.mysql.jdbc.Connection;public class DBUtils {\t /**\t  * 获取数据库连接\t * @return Connection对象\t */\tpublic static Connection getConnection(){\t\tString dbUserName = \"root\";\t\tString dbUserPasswd = \"123456\";\t\tString dbURL = \"jdbc:mysql://localhost:3306/studentinfomanagement?\"\t\t            + \"user=\"+dbUserName+\"&amp;password=\"+dbUserPasswd+\"&amp;useUnicode=true&amp;characterEncoding=UTF8\";\t\tConnection conn = null;\t\ttry {\t\t\tClass.forName(\"com.mysql.jdbc.Driver\");\t\t\tconn = (Connection) DriverManager.getConnection(dbURL,dbUserName,dbUserPasswd);\t\t} catch (ClassNotFoundException | SQLException e) {\t\t\te.printStackTrace();\t\t} \t\treturn conn;\t}\t\t/**\t         * 关闭数据库连接\t * @param conn Connection对象\t */\tpublic static void closeConnection(Connection conn) {\t\t//判断conn是否为空\t\tif(conn != null){\t\t\ttry {\t\t\t\tconn.close();//关闭数据库连接\t\t\t} catch (SQLException e) {\t\t\t\t// TODO: handle exception\t\t\t\te.printStackTrace();\t\t\t}\t\t}\t}}（三）设计所需要的Servlet再所创建的servlet中，可以在web.xml下进行相关配置，也可使用注解的方式声明servlet，本项目在web.xml下配置相关信息。（四）设计系统所需要的JSP页面五、部分实现截图：1.登录进来后的页面：2.查询页面：3.新增页面：4.删除页面：5.修改页面："
  },
  
  {
    "title": "02-双向数据绑定及逻辑控制指令",
    "url": "/posts/02-%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A%E5%8F%8A%E9%80%BB%E8%BE%91%E6%8E%A7%E5%88%B6%E6%8C%87%E4%BB%A4/",
    "categories": "Vue实训",
    "tags": "课程",
    "date": "2023-06-06 22:49:00 +0800",
    





    
    "snippet": "Vue 第 2 天 - 双向数据绑定及逻辑控制指令视频链接：视频链接代码链接：代码链接01 - 双向数据绑定 v-model （重点）  文档  https://cn.vuejs.org/guide/essentials/forms.html  作用:：表单元素的绑定，实现了双向数据绑定，通过表单项可以更改数据。  v-model 会忽略所有表单元素的 value、checked、selec...",
    "content": "Vue 第 2 天 - 双向数据绑定及逻辑控制指令视频链接：视频链接代码链接：代码链接01 - 双向数据绑定 v-model （重点）  文档  https://cn.vuejs.org/guide/essentials/forms.html  作用:：表单元素的绑定，实现了双向数据绑定，通过表单项可以更改数据。  v-model 会忽略所有表单元素的 value、checked、selected 特性的初始值,而总是将 Vue 实例的数据作为数据来源，应该在 data 选项中声明初始值。      普通文本框上的使用    &lt;div id='app'&gt;    &lt;p&gt;&lt;/p&gt;    &lt;input type='text' v-model='message'&gt;    &lt;!--    v-model其实是`语法糖`,它是下面这种写法的简写    语法糖：这种语法对语言的功能并没有影响，但是更方便程序员使用    --&gt;    &lt;input type='text' :value='msg' @input='msg=$event.target.value'/&gt;&lt;/div&gt;  &lt;script type=\"module\"&gt;    import { createApp } from './vue.js';    createApp({      data: function () {        return {          msg: '要不要再来?'        }      }    }).mount('#app')  &lt;/script&gt;        多行文本框上的使用    &lt;div id='app'&gt;    &lt;textarea v-model=\"message\"&gt;&lt;/textarea&gt;&lt;/div&gt;  &lt;script type=\"module\"&gt;    import { createApp } from './vue.js';    createApp({      data: function () {        return {          msg: '要不要再来?'        }      }    }).mount('#app')  &lt;/script&gt;    注意：在多行文本框中使用插值表达式无效（此时，其只能接受数据，不能改变数据）      单个复选框上的使用    &lt;div id='app'&gt;    &lt;input type=\"checkbox\" v-model=\"checked\"&gt;&lt;/div&gt;  &lt;script type=\"module\"&gt;    import { createApp } from './vue.js';    createApp({      data: function () {        return {          checked: true        }      }    }).mount('#app')  &lt;/script&gt;        多个复选框上的使用    &lt;div id='app'&gt;    &lt;input type=\"checkbox\" value=\"html\" v-model=\"checkedNames\"&gt;    &lt;input type=\"checkbox\" value=\"css\" v-model=\"checkedNames\"&gt;    &lt;input type=\"checkbox\" value=\"js\" v-model=\"checkedNames\"&gt;&lt;/div&gt;  &lt;script type=\"module\"&gt;    import { createApp } from './vue.js';    createApp({      data: function () {        return {          // 如果数组中有对应的value值，则此checkbox会被选中          checkedNames: ['html']        }      }    }).mount('#app')  &lt;/script&gt;    注意：此种用法需要input标签提供value属性，并且需要注意属性的大小写要与数组元素的大小写一致      单选按钮上的使用    &lt;div id='app'&gt;    男&lt;input type=\"radio\" name=\"sex\" value=\"男\" v-model=\"sex\"&gt;\t  女&lt;input type=\"radio\" name=\"sex\" value=\"女\" v-model=\"sex\"&gt;&lt;/div&gt;  &lt;script type=\"module\"&gt;    import { createApp } from './vue.js';    createApp({      data: function () {        return {                sex: \"女\"        }      }    }).mount('#app')  &lt;/script&gt;        下拉框上的使用    &lt;div id='app'&gt;    &lt;select v-model=\"selected\"&gt;        &lt;option&gt;请选择&lt;/option&gt;        &lt;option&gt;HTML&lt;/option&gt;        &lt;option&gt;CSS&lt;/option&gt;        &lt;option&gt;JS&lt;/option&gt;    &lt;/select&gt;&lt;/div&gt;  &lt;script type=\"module\"&gt;    import { createApp } from './vue.js';    createApp({      data: function () {        return {                  selected: 'JS'        }      }    }).mount('#app')  &lt;/script&gt;        修饰符的使用    .lazy：默认情况下Vue的数据同步采用input事件，使用.lazy将其修改为失去焦点时触发  .number：自动将用户的输入值转为数值类型（如果能转的话）  .trim：自动过滤用户输入的首尾空白字符02 - v-model 语法糖的本质            v-model 其本质上来讲是 在表单上监听用户对应输入事件，动态的修改 data 中声明的属性的一个方法。              我们也把这种封装出来的使用，叫做「语法糖」，简单的来说，就是方便开发者使用的，在程序员的世界里，永远有一个最基础的规矩，就是「Write Less， Do More」，写的更少，做的更多。        &lt;body&gt;    &lt;div id=\"app\"&gt;        &lt;input type=\"text\" @input=\"setMsg\" /&gt;        &lt;h2&gt;你输入的内容是：&lt;/h2&gt;    &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;  &lt;script type=\"module\"&gt;    import { createApp } from './vue.js';    createApp({      data: function () {        return {          msg: '汉宫秋月'        }      },      methods: {        setMsg(e) {          this.msg = e.target.value;        }      }    }).mount('#app')  &lt;/script&gt;  03 - v-for 循环控制指令  文档: https://cn.vuejs.org/guide/essentials/list.html#v-for  用 v-for 指令基于一个数组来渲染一个列表            v-for 用来遍历数组并生成多个标签              v-for 作用在需要重复的元素上              语法 v-for=\"元素别名 in 数组\" 或者 v-for=\"(元素别名,下标别名) in 数组\"              在 v-for 作用的标签之间就可以用使用元素别名和下标别名        in 是固定的，不能变    注意 v-for 必须要配套一个 key 来进行使用，这样 Vue 才能区分每一个元素的标识，进而在局部更新一个数据的时候，才能配套使用 diff 算法来确保更新的效率    &lt;div id=\"app\"&gt;  &lt;ul&gt;    &lt;li v-for=\"(movie,index) in movieList\" key=\"'movie'+index\"&gt;       -- &lt;/li&gt;  &lt;/ul&gt;&lt;/div&gt;  &lt;script type=\"module\"&gt;    import { createApp } from './vue.js';    createApp({      data: function () {        return {          movieList: [            '生死罗布泊',            '淮海战役',            '辽沈战役'          ]        }      }    }).mount('#app')  &lt;/script&gt;  04- Demo 记事本  实现步骤      展示任务列表    添加任务    删除任务    注意点            v-for=“（元素别名,下标别名） in 数组”        v-model修饰符              修饰符：                  .lazy - 取代 input 监听 change 事件                            .number - 输入字符串转为有效的数字        .trim - 输入首尾空格过滤              array.splice(从哪个下标开始删除，删除元素的个数)      /*  1.展示任务列表    1. todoList:['睡觉觉','吃饭饭','打豆豆']    2. v-for=\"元素别名 in 数组\" li就可以使用元素别名  2. 添加任务    1.v-model:inputVal    2.@keyup.enter=\"addTodo\"    3.todoList.push(inputVal)  3.删除任务    1. @dblclick:delTodo(index)    2. index来自v-for    3.delTodo todoList.splice(从哪个下标开始删除,删除多少项)  */  05 - v-if、v-else-if、v-else 分支控制指令  官方文档  v-if 指令用于条件性地渲染一块内容。这块内容只会在指令的表达式返回 truthy 值的时候被渲染。      v-if=\"js表达式\" 和 v-else-if=“js表达式\"，如果表达式值为 true，才会渲染该元素    v-else 以上的条件不满足时，渲染该元素      &lt;div id=\"app\"&gt;    &lt;h2&gt;老弟，你今年岁&lt;/h2&gt;    &lt;input type=\"text\" v-model=\"age\" /&gt;    &lt;h2 v-if=\"age&lt;18\"&gt;打枪的不要,暗恋悄悄的&lt;/h2&gt;    &lt;h2 v-else-if=\"age&lt;25\"&gt;光明正大去网吧&lt;/h2&gt;    &lt;h2 v-else&gt;你到了晚婚的年龄了&lt;/h2&gt;  &lt;/div&gt;  &lt;script type=\"module\"&gt;    import { createApp } from './vue.js';    createApp({      data: function () {        return {          age: 22        }      }    }).mount('#app')  &lt;/script&gt;  06 - v-show 条件显示指令  手册 https://cn.vuejs.org/guide/essentials/conditional.html#v-show  v-show 只是简单地切换元素的 CSS 属性 display。      v-show 隐藏元素通过改变元素 css 属性 display:none    v-if 隐藏元素直接移除 dom    对于频繁切换隐藏和显示的元素，就用 v-show    &lt;div id=\"app\"&gt;  &lt;button @click=\"isShow=!isShow\"&gt;切换显示&lt;/button&gt;  &lt;h2&gt;使用v-if&lt;/h2&gt;  &lt;h2 v-if=\"isShow\"&gt;中分还带波浪，是不是很萌呢&lt;/h2&gt;  &lt;h2&gt;使用v-show&lt;/h2&gt;  &lt;h2 v-show=\"isShow\"&gt;中分还带波浪，是不是很萌呢&lt;/h2&gt;&lt;/div&gt;  &lt;script type=\"module\"&gt;    import { createApp } from './vue.js';    createApp({      data: function () {        return {          isShow:true        }      }    }).mount('#app')  &lt;/script&gt;  07 - v-cloak 隐藏胡子语法指令  v-clock 指令和 CSS 规则如 [v-cloak] { display: none }一起用时，这个指令可以隐藏未编译的 Mustache 标签直到实例准备完毕。      添加了这个指令之后, Vue解析完后，会移除该指令          v-cloak和 display:none 结合使用，可以隐藏未编译的  语法        我们可以使用 slow 3G 模拟低速网络来体验， disable cache 请求的资源不会在浏览器缓存，下一次请求同一资源还会请求服务器      &lt;style&gt;    [v-cloak] {      display: none;    }  &lt;/style&gt;&lt;body&gt;  &lt;div id=\"app\"&gt;    &lt;h2 v-cloak&gt;&lt;/h2&gt;  &lt;/div&gt;  &lt;script type=\"module\"&gt;    import { createApp } from './vue.js';    createApp({      data() {        return {          message: \"Hello World\"        }      }    }).mount('#app')  &lt;/script&gt;&lt;/body&gt;  08 - v-pre 跳过编译过程（了解）  跳过这个元素和它的子元素的编译过程。  &lt;div id=\"app\"&gt;  &lt;span v-pre&gt;&lt;/span&gt;&lt;/div&gt;&lt;script src=\"./lib/vue.js\"&gt;&lt;/script&gt;&lt;script&gt;  const app = new Vue({    el: '#app',    data: {}  })&lt;/script&gt;  09 - 课后作业      灵活使用 v-model 指令获取表单信息    灵活使用 v-if、v-show 逻辑控制语句    完成相关 Demo 案例  "
  },
  
  {
    "title": "CloudFlare 造成重定向的次数过多",
    "url": "/posts/cloudflare-%E9%80%A0%E6%88%90%E9%87%8D%E5%AE%9A%E5%90%91%E7%9A%84%E6%AC%A1%E6%95%B0%E8%BF%87%E5%A4%9A/",
    "categories": "心得",
    "tags": "建站",
    "date": "2023-06-06 14:08:00 +0800",
    





    
    "snippet": "一句话解决在 CloudFlare 的 SSL/TLS 菜单里将「SSL/TLS 加密模式」设置为完全（Strict）即可。  以下内容转载自 CSDN 博主「补了个丁」的原创文章，遵循 CC 4.0 BY-SA 版权协议。原文链接：https://blog.csdn.net/weixin_29405101/article/details/112659223CloudFlare 造成重定向的...",
    "content": "一句话解决在 CloudFlare 的 SSL/TLS 菜单里将「SSL/TLS 加密模式」设置为完全（Strict）即可。  以下内容转载自 CSDN 博主「补了个丁」的原创文章，遵循 CC 4.0 BY-SA 版权协议。原文链接：https://blog.csdn.net/weixin_29405101/article/details/112659223CloudFlare 造成重定向的次数过多的原因当网站开启了 CloudFlare 服务，用户访问我们的网站时，其实访问的离用户比较近的 Cloudflare 服务器，Cloudflare 再代理用户请求我们的源服务器，以达到加速和保护源服务器的目的。Cloudflare 代理用户请求我们源服务器获取网页资源的过程叫回源。Cloudflare 造成循环重定向的错误就出在了回源的过程中，造成这种错误的原因就是 http 和 https 之间的重定向。Cloudflare Crypto 的 SSL 中有 4 个选项 (如下)，其中 Off 就是不启用 SSL，通过 HTTP 协议访问网站。另外 3 种是通过 HTTPS 协议访问网站。Cloudflare CDN 配置Flexible：当我们的源网站没有配置 HTTPS 支持时，启用这个选项，Cloudflare 会在回源的时候通过 HTTP 协议访问我们的网站。Full：当我们的源网站支持 HTTPS，但是 HTTPS 证书和域名不匹配或者是自签名证书时，Cloudflare 会通过 HTTPS 协议访问源网站，但不会验证证书，也就是说，即使我们的源网站提供的 HTTPS 证书不受浏览器信任，Cloudflare 也会通过 HTTPS 回源网站。Full (strict)：当我们的源网站支持 HTTP ，并且证书有效时 (未过期且受信任)。Cloudflare 会通过 HTTPS 协议访问源网站，并在每个请求过程中验证证书。了解了上面各个设置的功能，我们来看一下 Cloudflare 的循环重定向问题是怎么出现的，在 Cloudflare 中开启了 SSL 后，访问网站时出现循环重定向需满足下面两个条件：SSL 中设置了 Flexible，CDN 以 HTTP 协议回源网站。源网站支持 HTTPS，并且设置了通过 HTTP 协议访问时，自动跳转到 HTTPS 协议。到这里，可能就有朋友发现问题了，我们访问 Cloudflare 的 CDN 服务器的时候，是通过 HTTPS 访问的，CDN 访问源网站的时候，是通过 HTTP 访问的，源网站上 HTTP 又自动跳转了 HTTPS，完美的一个循环重定向。重定向的次数多了，浏览器就撂挑子报出了 ERR_TOO_MANY_REDIRECTS 的错误。CloudFlare 造成重定向的次数过多问题的解决办法知道了循环重定向的原因，我们也就知道了怎么解决这个问题，通过测试，下面的两种设置方法都可以解决 Cloudflare 循环重定向的问题。SSL 中选择 Full (strict) 或者 Full (strict)，让 CDN 回源的时候使用 HTTPS 的方式回源，没有 HTTP 什么事了，就不会跳来跳去了源网站不设置 HTTPS 支持或者 不设置 HTTP 跳转 HTTPS，让 Cloudflare 回源的时候使用 HTTP 方式获取资源。修改了 CloudFlare 设置后，可能需要过几分钟或清理浏览器缓存后才能生效。除了 Cloudflare，使用其他 CDN 提供商的时候，也可能会出现这个问题，如果设置了 CDN 后，遇到了 Chrome 报重定向次数过多的问题，可以通过上面的思路查找问题。如果你在使用其他 CDN 的时候也遇到了类似的问题，欢迎在评论中提出，让更多的朋友看到。"
  },
  
  {
    "title": "1-初识Vue",
    "url": "/posts/1-%E5%88%9D%E8%AF%86vue/",
    "categories": "Vue实训",
    "tags": "课程",
    "date": "2023-06-05 14:07:00 +0800",
    





    
    "snippet": "Vue 第 1 天 - 初识 Vue 及基础指令视频链接：视频链接代码链接：代码链接一 利其器  学习方法推荐      工具学习相对简单，使用场景更重要    学习模式「讲一半、练一半」勤动手    学完后认真完成作业，讲究学以致用    不要强迫性焦虑，练着练着也就会了    认真对待企业项目实战，简历中会用    坚持刷刷面试经，面试这一关造火箭  二 认识01- Vue 概述  作者...",
    "content": "Vue 第 1 天 - 初识 Vue 及基础指令视频链接：视频链接代码链接：代码链接一 利其器  学习方法推荐      工具学习相对简单，使用场景更重要    学习模式「讲一半、练一半」勤动手    学完后认真完成作业，讲究学以致用    不要强迫性焦虑，练着练着也就会了    认真对待企业项目实战，简历中会用    坚持刷刷面试经，面试这一关造火箭  二 认识01- Vue 概述  作者：尤雨溪.  官网：https://cn.vuejs.org  Vue.js 是一套构建用户界面的渐进式框架，采用自底向上增量开发的设计。            渐进式：一步一步，不是说你必须一次把所有的东西都用上        自底向上设计：是一种设计程序的过程和方法，就是先编写出基础程序段，然后再逐步扩大规模、补充和升级某些功能，实际上是一种自底向上构造程序的过程。              Vue 从设计角度来讲，虽然能够涵下图所有的东西，但是你并不需要一上手就把所有东西全用上，都是可选的。声明式渲染和组件系统 是 Vue 的核心库所包含内容，而路由、状态管理、构建工具都有专门解决方案。这些解决方案相互独立，我们可以在核心的基础上任意选用其他的部件，不一定要全部整合在一起。                      Vue 仍然是国内最火的框架之一               ![Vue与react在github上](https://storage.lynnn.cn/assets/markdown/91147/pictures/2020/09/229fe902962263af21443024e14a78b54ea5c3d1.png?sign=976600758fc879cea5db0a54774e1bda&amp;t=5f5070ea)                            02 - JS 表达式            [官方文档] https://cn.vuejs.org/guide/essentials/template-syntax.html#%E4%BD%BF%E7%94%A8-javascript-%E8%A1%A8%E8%BE%BE%E5%BC%8F        JS 表达式概念                        JS 表达式概念：JS 语句，返回一个值                            ``    基础运算是表达式        `   ` 三元运算符是表达式        ` `   const 是声明语句，不是表达式        { { if }} 、`` 是逻辑语句，不是表达式，不能直接使用        `` map 是表达式，因为 map 会返回一个新的数组              在 Vue 的胡子语法中，可以使用 插值 表达式      &lt;div id=\"app\"&gt;    &lt;p&gt;&lt;/p&gt;    &lt;p&gt;&lt;/p&gt;    &lt;p&gt;&lt;/p&gt;  &lt;/div&gt;  &lt;script type=\"module\"&gt;    import { createApp } from './vue.js';    createApp({      data() {        return {          msg: '穷则变,变则通,通则久',          num: 1,          isRed: false        }      }    }).mount('#app')  三 Vue 内置指令      Vue 指令  Directives 是带有 v- 前缀的标记性属性标签，交给 Vue 解析其特有的规则    Vue 指令简单来讲，就是 Vue 提供给 HTML 标签新增的自定义属性，代表一定的 Vue 语法意义    用法和  HTML 属性一样，但是，一定要注意 自定义指令后 引号内部的是 JS 表达式，会被当做 JS 来进行解析  https://cn.vuejs.org/api/built-in-directives.html01 - v-text 指令 插入文本内容            v-text 把值作为文本插入到所在的标签之间              Vue 内部是 textContent 实现的              会覆盖掉标签之间的文本              简写 ``，简写用得更多              不能解析html              ```html                                                             ```      02 - v-html 指令 插入标签内容            v-html 是把值作为html插入到所在的标签之间，内部实现是 innerHTML，会覆盖标签之间的 html              没有简写              ```html                                        666                 ```      03 - v-on 指令快速绑定事件手册: https://cn.vuejs.org/guide/essentials/event-handling.html      v-on:事件名=\"事件处理方法\"    事件处理方法声明在 methods 对象里边，methods,data 并列    简写 @事件名=\"事件处理方法\" 当然推荐用简写    事件名和原生的事件名一致，可以是 dblclick,click,mouseover,keyup,keyenter....     事件处理方法的默认参数是 event对象    方法传参和原来 HTML 注册事件方法没什么分别    &lt;body&gt;  &lt;div id=\"app\"&gt;    &lt;input type=\"button\" v-on:click=\"inputFn\" value=\"点我\"&gt;    &lt;input type=\"button\" @click=\"green\" value=\"简写的\"&gt;    &lt;input type=\"button\" @click=\"eventFn\" value=\"evnt接收\"&gt;    &lt;!-- 如果行内传递参数,event也要传递 --&gt;    &lt;input type=\"button\" @click=\"clickFn('来自行内的',$event)\" value=\"传递参数\"&gt;  &lt;/div&gt;  &lt;script type=\"module\"&gt;    import { createApp } from './vue.js';    createApp({      data: function () {        return {          mes: '学习是一种习惯',          alink: '&lt;a href=\"http://www.baidu.com\"&gt; 神奇的网站&lt;/a&gt;'        }      },      methods: {        inputFn() {          console.log('在被点击...');        },        green() {          console.log('简写也ok');        },        eventFn(e) {          console.log(e);        },        clickFn(msg, e) {          console.log(msg, e);          console.log(window.event);        }      }    }).mount('#app')  04 - 简洁方便的事件修饰符  文档:  https://cn.vuejs.org/guide/essentials/event-handling.html#event-modifiers  使用方法： v-on:事件名.修饰符 = \"事件处理方法\"  &lt;!-- 阻止单击事件继续传播 --&gt;&lt;a v-on:click.stop=\"doThis\"&gt;&lt;/a&gt;&lt;!-- 提交事件不再重载页面 --&gt;&lt;form v-on:submit.prevent=\"onSubmit\"&gt;&lt;/form&gt;&lt;!-- 修饰符可以串联 --&gt;&lt;a v-on:click.stop.prevent=\"doThat\"&gt;&lt;/a&gt;&lt;!-- 只当在 event.target 是当前元素自身时触发处理函数 --&gt;&lt;!-- 即事件不是从内部元素触发的 --&gt;&lt;div v-on:click.self=\"doThat\"&gt;...&lt;/div&gt;&lt;!-- 只有在 `key` 是 `Enter` 时调用 `vm.submit()` --&gt;&lt;input v-on:keyup.enter=\"submit\"&gt;    &lt;body&gt;  &lt;div id=\"app\"&gt;    &lt;div @click=\"fn1\" class=\"one\"&gt;      &lt;!-- stop 阻止冒泡 --&gt;      &lt;div @click.stop=\"fn2\" class=\"two\"&gt;&lt;/div&gt;    &lt;/div&gt;    &lt;!-- prevent 阻止默认行为 --&gt;    &lt;br /&gt;    &lt;br /&gt;    &lt;a @click.prevent=\"fn3\" href=\"\"&gt; 不动&lt;/a&gt;    &lt;br /&gt;    &lt;br /&gt;    &lt;!-- 点击的元素为自身才触发 --&gt;    &lt;div @click.self=\"fn4\" class=\"one\"&gt;      &lt;div class=\"two\"&gt;&lt;/div&gt;    &lt;/div&gt;  &lt;/div&gt;  &lt;script type=\"module\"&gt;    import { createApp } from './vue.js';    createApp({      data: function () {        return {          mes: '学习是一种习惯',          alink: '&lt;a href=\"http://www.baidu.com\"&gt; 神奇的网站&lt;/a&gt;'        }      },      methods: {        fn1() {          console.log('fn1...');        },        fn2() {          console.log('fn2...');        },        fn3() {          console.log('fn3...');        },        fn4() {          console.log('fn4...');        }      }    }).mount('#app')  &lt;/script&gt;  &lt;style&gt;    .one {      width: 100px;      height: 100px;      background: red;    }    .two {      width: 50px;      height: 50px;      background: green;    }  &lt;/style&gt;&lt;/body&gt;  按键修饰符&lt;body&gt;  &lt;div id=\"app\"&gt;    &lt;!-- 仅在 `key` 为 `Enter` 时调用 `submit` --&gt;    &lt;input type=\"button\" value=\"按回车触发\" @keyup.enter=\"submit\" /&gt;  &lt;/div&gt;  &lt;script type=\"module\"&gt;    import { createApp } from './vue.js';    createApp({      methods: {        submit() {          console.log('按下触发...');        }      }    }).mount('#app')  &lt;/script&gt;&lt;/body&gt;05 - 在 Vue 方法中使用 this 对象  文档:https://cn.vuejs.org/api/options-state.html#methods    方法中的 this 自动绑定为 Vue 实例。      方法里面的 this 就是 Vue 实例。    方法里面的 this 可以直接访问到 data 的属性和 methods 的方法。    Vue 里面属性值改变，对应视图将会「响应」我们也叫做响应式对象。    '&lt;body&gt;  &lt;div id=\"app\"&gt;    &lt;div&gt;&lt;/div&gt;    &lt;p @click=\"fn\"&gt;常常做不怕千万事&lt;/p&gt;  &lt;/div&gt;  &lt;script type=\"module\"&gt;    import { createApp } from './vue.js';    createApp({      data() {        return {          message: '扬眉吐气!',          hobby: {            name: 'zs',            age: 22          }        }      }      , methods: {        fn() {          console.log(this);          console.log(this.message);          console.log(this.hobby);          this.say();        },        say() {          console.log('毛主席,斗而不破...');        }      }    }).mount('#app')  &lt;/script&gt;&lt;/body&gt;  06 - v-bind 指令 动态绑定属性  文档   https://cn.vuejs.org/api/built-in-directives.html#v-bind      v-bind 指令，绑定属性，可以动态绑定 HTML 标签的属性    v-bind 指令的使用 v-bind:属性名=\"js表达式\"    v-bind: src=“imgUrl”， src 属性绑定到 imgUrl,  改变 imgUrl，会动态改变 src 的值    v-bind：可以简写为 ` :属性名＝”js表达式”`　当然推荐简写    ｖ-bind:class 动态改变 className 进而改变样式                        三元运算切换样式                            对象语法 {类名：是否添加样式}        可以直接绑定数组多个 className              v-bind:style=\"js对象\"动态直接改变样式                        对象的key如果是中划线边连接，建议用字符串或者驼峰 \"background-color\" backgroundColor                      &lt;body&gt;  &lt;div id=\"app\"&gt;    &lt;img v-bind:src=\"img\" @click=\"changeImg\"&gt;  &lt;/div&gt;  &lt;script type=\"module\"&gt;    import { createApp } from './vue.js';    createApp({      data() {        return {          img: '../images/10.jpg'        }      },      methods: {        changeImg() {          this.img = '../images/12.jpg';        }      }    }).mount('#app')  &lt;/script&gt;&lt;/body&gt;    &lt;body&gt;  &lt;div id=\"app\"&gt;    &lt;div :class=\"bgRed\"&gt;试探底线&lt;/div&gt;    &lt;div :class=\"isRed?'red':''\" @click=\"isRed=!isRed\"&gt;毫无下限&lt;/div&gt;    &lt;div :class=\"{'green':isGreen}\" @click=\"isGreen=!isGreen\"&gt;统一战线&lt;/div&gt;  &lt;/div&gt;  &lt;script type=\"module\"&gt;      //     import { createApp } from './vue.js';    createApp({      data() {        return {          bgRed: 'red',          isRed: true,          isGreen: true        }      },    }).mount('#app')  &lt;/script&gt;&lt;/body&gt;    &lt;body&gt;  &lt;div id=\"app\"&gt;    &lt;div style=\"background: color\"&gt;努力,努力,在努力&lt;/div&gt;    &lt;!-- 一次绑定多个class --&gt;    &lt;div :class=\"[classA, classB]\"&gt;多个class&lt;/div&gt;    &lt;!-- 注意牵扯到表达式,要带{},里面的值要加 '' --&gt;    &lt;div :style=\"{background:isGreen?'green':'red',color:'skyblue'}\"&gt; 奋斗一次,不枉此生 &lt;/div&gt;    &lt;!-- 自定义属性 --&gt;    &lt;div v-bind=\"{'data-id':gId}\"&gt;心常用则活,不用则窒&lt;/div&gt;  &lt;/div&gt;  &lt;script type=\"module\"&gt;    import { createApp } from './vue.js';    createApp({      data() {        return {          classA: 'one',          classB: 'two',          isGreen: true,          gId: 123        }      },    }).mount('#app')  &lt;/script&gt;&lt;/body&gt;  07- Demo 计数器  #### 实现步骤1. 使用 vue语法 直接绑定响应式对象，用来显示数字2. 加、减功能的实现，定义点击事件，调用对应方法3. 数字的范围是 0---10，如果数字超过边界- 可以动态给 button 按钮添加 disable 属性  &lt;body&gt;  &lt;div id=\"app\"&gt;    &lt;input type=\"button\" value=\"-\" :disabled=\"disStatus\" @click=\"reduce\"&gt; &amp;nbsp; &amp;nbsp;    &lt;span&gt;&lt;/span&gt;    &amp;nbsp; &amp;nbsp;    &lt;input type=\"button\" value=\"+\" :disabled=\"incStatus\" @click=\"increase\"&gt;  &lt;/div&gt;  &lt;script type=\"module\"&gt;    import { createApp } from './vue.js';    createApp({      data() {        return {          num: 0,          disStatus: false,          incStatus: false,          showClass: false        }      },      methods: {        reduce() {          this.num--          if (this.num == 0) {            this.disStatus = true;          }          this.incStatus = false        },        increase() {          this.num++          if (this.num == 10) {            this.incStatus = true;          }          this.disStatus = false        }      }    }).mount('#app')  &lt;/script&gt;&lt;/body&gt;08- Demo 图片切换  #### 实现步骤      做一个数组在 data 中，用来存放图片列表    图片显示区域用来展示图片，src 属性 使用 v-bind 进行绑定，初始值为第一张照片    点击上一张、下一张两个按钮，绑定执行事件    根据事件切换 src 绑定的图片地址    到达边界进行逻辑计算，实现循环切换效果  09 - Vue 核心原理理解及原生 JS 实现      声明式渲染，模板引擎              Vue.js 的核心是一个允许采用简洁的模板语法来声明式的将数据渲染进 DOM 的系统，简单来说，就是在 JavaScript 中写变量，然后，可以通过一定的语法规则，直接渲染到页面上        ```html                                                                      &lt;/html&gt;```            组件化应用构建，模块复用              组件系统是 Vue 的另一个重要概念（后续学习），因为它是一种抽象的允许我们使用小型、独立和通常可复用的“小积木”构建大型应用，几乎任意类型的应用界面都可以抽象为一个组件树。简单来说，其实就是将一个模块封装为一个函数（对象），然后可以快速的进行复用                ```html                            &lt;/html&gt;```            响应式数据对象双向绑定              Vue 中使用响应式数据对象声明，进而驱动页面行为。通俗的讲就是：                  在 js 中修改了数据，在页面中的 DOM 直接就配合进行修改数据                            同时，在 DOM 表单中用户操作修改了数据，js 中也同步接收这个数据。                      vue2的数据绑定            ```html                                  你好          &lt;/html&gt;```      vue3 的数据绑定&lt;body&gt;  &lt;div&gt;    &lt;button&gt;改变uname&lt;/button&gt;    &lt;input type=\"text\" name=\"user\" id=\"user\"&gt;    &lt;h1&gt;&lt;/h1&gt;  &lt;/div&gt;  &lt;script&gt;    // 页面中数据变化,可以影响js中对象,对象的修改也可以直接影响页面    let userinfo = {      uname: '小甜甜'    }    let proxy = '';    function watcher() {      proxy = new Proxy(userinfo, {        set(target, key, val) {          if (key == 'uname') {            updateDOM(val)          }        }      })    }    watcher();    function updateDOM(val) {      // 修改input和h1中的值      document.querySelector('h1').innerHTML = val;      document.querySelector('input').value = val;    }    // 直接修改对象    document.querySelector('button').onclick = function () {      proxy.uname = '大甜甜';    }    // 给input绑定输入事件    document.querySelector('input').oninput = function () {      // 将input的值设置给userinfo      proxy.uname = this.value;    }  &lt;/script&gt;&lt;/body&gt;10 - 课后作业      勤学苦练相关 Vue 指令    完成 计数器、图片切换 两个 Demo    基于 js 源码来理解 Vue 的一些核心概念（选修）  "
  },
  
  {
    "title": "jekyll建站",
    "url": "/posts/my-new-post/",
    "categories": "心得",
    "tags": "建站",
    "date": "2023-05-29 21:37:00 +0800",
    





    
    "snippet": "jekyll建站心得chirpy踩坑解决办法自定义域名",
    "content": "jekyll建站心得chirpy踩坑解决办法自定义域名"
  },
  
  {
    "title": "Text and Typography",
    "url": "/posts/helpdocx/",
    "categories": "",
    "tags": "",
    "date": "2019-08-08 11:33:00 +0800",
    





    
    "snippet": "HeadingsH1 - headingH2 - headingH3 - headingH4 - headingParagraphQuisque egestas convallis ipsum, ut sollicitudin risus tincidunt a. Maecenas interdum malesuada egestas. Duis consectetur porta risu...",
    "content": "HeadingsH1 - headingH2 - headingH3 - headingH4 - headingParagraphQuisque egestas convallis ipsum, ut sollicitudin risus tincidunt a. Maecenas interdum malesuada egestas. Duis consectetur porta risus, sit amet vulputate urna facilisis ac. Phasellus semper dui non purus ultrices sodales. Aliquam ante lorem, ornare a feugiat ac, finibus nec mauris. Vivamus ut tristique nisi. Sed vel leo vulputate, efficitur risus non, posuere mi. Nullam tincidunt bibendum rutrum. Proin commodo ornare sapien. Vivamus interdum diam sed sapien blandit, sit amet aliquam risus mattis. Nullam arcu turpis, mollis quis laoreet at, placerat id nibh. Suspendisse venenatis eros eros.ListsOrdered list  Firstly  Secondly  ThirdlyUnordered list  Chapter          Section                  Paragraph                    ToDo list  Job          Step 1      Step 2      Step 3      Description list  Sun  the star around which the earth orbits  Moon  the natural satellite of the earth, visible by reflected light from the sunBlock Quote  This line shows the block quote.Prompts  An example showing the tip type prompt.  An example showing the info type prompt.  An example showing the warning type prompt.  An example showing the danger type prompt.Tables            Company      Contact      Country                  Alfreds Futterkiste      Maria Anders      Germany              Island Trading      Helen Bennett      UK              Magazzini Alimentari Riuniti      Giovanni Rovelli      Italy      Linkshttp://127.0.0.1:4000FootnoteClick the hook will locate the footnote1, and here is another footnote2.Inline codeThis is an example of Inline Code.FilepathHere is the /path/to/the/file.extend.Code blocksCommonThis is a common code snippet, without syntax highlight and line number.Specific Languageif [ $? -ne 0 ]; then  echo \"The command was not successful.\";  #do the needful / exitfi;Specific filename@import  \"colors/light-typography\",  \"colors/dark-typography\";MathematicsThe mathematics powered by MathJax:\\[\\sum_{n=1}^\\infty 1/n^2 = \\frac{\\pi^2}{6}\\]When $a \\ne 0$, there are two solutions to $ax^2 + bx + c = 0$ and they are\\[x = {-b \\pm \\sqrt{b^2-4ac} \\over 2a}\\]Mermaid SVG gantt  title  Adding GANTT diagram functionality to mermaid  apple :a, 2017-07-20, 1w  banana :crit, b, 2017-07-23, 1d  cherry :active, c, after b a, 1dImagesDefault (with caption)Full screen width and center alignmentLeft alignedFloat to leftPraesent maximus aliquam sapien. Sed vel neque in dolor pulvinar auctor. Maecenas pharetra, sem sit amet interdum posuere, tellus lacus eleifend magna, ac lobortis felis ipsum id sapien. Proin ornare rutrum metus, ac convallis diam volutpat sit amet. Phasellus volutpat, elit sit amet tincidunt mollis, felis mi scelerisque mauris, ut facilisis leo magna accumsan sapien. In rutrum vehicula nisl eget tempor. Nullam maximus ullamcorper libero non maximus. Integer ultricies velit id convallis varius. Praesent eu nisl eu urna finibus ultrices id nec ex. Mauris ac mattis quam. Fusce aliquam est nec sapien bibendum, vitae malesuada ligula condimentum.Float to rightPraesent maximus aliquam sapien. Sed vel neque in dolor pulvinar auctor. Maecenas pharetra, sem sit amet interdum posuere, tellus lacus eleifend magna, ac lobortis felis ipsum id sapien. Proin ornare rutrum metus, ac convallis diam volutpat sit amet. Phasellus volutpat, elit sit amet tincidunt mollis, felis mi scelerisque mauris, ut facilisis leo magna accumsan sapien. In rutrum vehicula nisl eget tempor. Nullam maximus ullamcorper libero non maximus. Integer ultricies velit id convallis varius. Praesent eu nisl eu urna finibus ultrices id nec ex. Mauris ac mattis quam. Fusce aliquam est nec sapien bibendum, vitae malesuada ligula condimentum.Dark/Light mode &amp; ShadowThe image below will toggle dark/light mode based on theme preference, notice it has shadows.VideoReverse Footnote            The footnote source &#8617;              The 2nd footnote source &#8617;      "
  }
  
]

